# Default values for Camunda Helm chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# The values file follows helm best practices https://helm.sh/docs/chart_best_practices/values/
#
# This means:
#   * Variable names should begin with a lowercase letter, and words should be separated with camelcase.
#   * Every defined property in values.yaml should be documented. The documentation string should begin with the name of the property that it describes, and then give at least a one-sentence description
#
# Furthermore, we try to apply the following pattern: # [VarName] [conjunction] [definition]
#
# VarName:
#
#  * In the documentation the variable name is started with a big letter, similar to kubernetes resource documentation.
#  * If the variable is part of a subsection/object we use a json path expression (to make it more clear where the variable belongs to).
#    The root (chart name) is omitted (e.g. zeebe). This is useful for using --set in helm.
#
# Conjunction:
#   * [defines] for mandatory configuration
#   * [can be used] for optional configuration
#   * [if true] for toggles
#   * [configuration] for section/group of variables

#------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------------------------#
##########################################
 #####
#     # #       ####  #####    ##   #
#       #      #    # #    #  #  #  #
#  #### #      #    # #####  #    # #
#     # #      #    # #    # ###### #
#     # #      #    # #    # #    # #
 #####  ######  ####  #####  #    # ######
##########################################
#------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------------------------#

# Global configuration for variables which can be accessed by all sub charts
## @section Global parameters
## @extra global
global:
  ## Secrets configuration.
  ## @extra global.secrets configuration for auto-generated secrets which is only used during the installation.
  secrets:
    ## @param global.secrets.autoGenerated if true, a secret object will be generated with auto-generated passwords. This secret object is NOT managed with corresponding releases and NOR part of Helm deployment/upgrade! It's generated once, and if it's deleted, you will lose the secrets.
    autoGenerated: false
    ## @param global.secrets.name defines the name of the secret object that has the auto-generated passwords.
    name: "camunda-credentials"
    ## @param global.secrets.annotations [object] defines the secret object annotations that utilize Helm hooks to keep that object out of the Helm deployment.
    annotations:
      helm.sh/hook: 'pre-install'
      helm.sh/resource-policy: 'keep'

  ## License configuration.
  ## @extra global.license
  license:
    ## @param global.license.key if set, it will be exposed as "CAMUNDA_LICENSE_KEY" in the apps.
    key: ""
    ## @param global.license.existingSecret you can provide an existing secret name for Camunda license secret.
    existingSecret: ""
    ## @param global.license.existingSecretKey you can provide the key within the existing secret object for Camunda license key.
    existingSecretKey: ""

  ## @extra global.compatibility Compatibility adaptations for Kubernetes platforms
  compatibility:
    ## Compatibility adaptations for Openshift
    ##
    openshift:
      ## @param global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: force (perform the adaptation always), disabled (do not perform adaptation)
      ##
      adaptSecurityContext: disabled

  ## Multitenancy configuration.
  ## @extra global.multitenancy
  multitenancy:
    ## @param global.multitenancy.enabled if true, then enable multitenancy in all applicable components.
    enabled: false

  ## Security configuration
  ## @extra global.security
  security:
    ## Authentication configuration
    ## @extra global.security.authentication
    authentication:
      ## @param global.security.authentication.method defines the authentication method which should be used. Possible values: basic, oidc
      method: basic
      ## @param global.security.authentication.unprotectedApi if true, then allow unauthenticated API access.
      unprotectedApi: false
    ## Authorizations configuration.
    ## @extra global.security.authorizations
    authorizations:
      ## @param global.security.authorizations.enabled if true, then enable authorizations checks in all applicable components.
      enabled: true
    ## Initialization configuration
    ## @extra global.security.initialization
    initialization:
      ## Initial admin users configurations
      ## @extra global.security.initialization.users
      ## @param global.security.initialization.users[0].username
      ## @param global.security.initialization.users[0].password
      ## @param global.security.initialization.users[0].name
      ## @param global.security.initialization.users[0].email
      users:
        ## @extra global.security.initialization.users.username, the username of an initial user.
        - username: demo
          ## @extra global.security.initialization.users.password, the password of an initial user.
          password: demo
          ## @extra global.security.initialization.users.name, the name of an initial user.
          name: Demo User
          ## @extra global.security.initialization.users.email, the email of an initial user.
          email: demo@demo.com

  ## @param global.createReleaseInfo Create config that will be used in Camunda Console.
  createReleaseInfo: true

  ## @skip global.testDeprecationFlags
  testDeprecationFlags:
    ## @skip global.testDeprecationFlags.existingSecretsMustBeSet give error or warning when existingSecret is not set
    existingSecretsMustBeSet: "error"

  ## @param global.annotations Annotations can be used to define common annotations, which should be applied to all deployments
  annotations: {}
  labels:
  ## @param global.labels.app Name of the application
    app: camunda-platform
  # Image configuration to be used in each sub chart
  # https://hub.docker.com/u/camunda
  image:
    ## @param global.image.registry Can be used to set container image registry.
    registry: ""
    ## @param global.image.tag defines the tag / version which should be used in the most of the apps.
    tag: ""
    ## @param global.image.pullPolicy defines the image pull policy which should be used https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy
    pullPolicy: Always
    ## @param global.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []
  ## Ingress configuration to configure the ingress resource
  ## @extra global.ingress
  ingress:
    ## @param global.ingress.enabled if true, an ingress resource is deployed. Only useful if an ingress controller is available, like Ingress-NGINX.
    enabled: false
    ## @param global.ingress.className Ingress.className defines the class or configuration of ingress which should be used by the controller
    className: nginx
    ## @param global.ingress.annotations [object] defines the ingress related annotations, consumed mostly by the ingress controller
    annotations:
      ingress.kubernetes.io/rewrite-target: '/'
      nginx.ingress.kubernetes.io/ssl-redirect: 'false'
      nginx.ingress.kubernetes.io/proxy-buffer-size: '128k'
      nginx.ingress.kubernetes.io/proxy-buffering: 'on'
      nginx.ingress.kubernetes.io/affinity: 'cookie'
      nginx.ingress.kubernetes.io/affinity-mode: 'persistent'
      nginx.ingress.kubernetes.io/session-cookie-name: 'route'
      nginx.ingress.kubernetes.io/session-cookie-path: '/'
    # Ingress.host can be used to define the host of the ingress rule. https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
    ## @param global.ingress.host If not specified the rules applies to all inbound http traffic, if specified the rule applies to that host.
    host: ""
    ## @param global.ingress.pathType can be used to define the Ingress path type. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types
    pathType: Prefix
    ## @extra global.ingress.tls configuration for tls on the ingress resource https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    tls:
      ## @param global.ingress.tls.enabled if true, then tls is configured on the ingress resource. If enabled the Ingress.host need to be defined.
      enabled: false
      ## @param global.ingress.tls.secretName defines the secret name which contains the TLS private key and certificate
      secretName: camunda-platform

  # Elasticsearch configuration which is shared between the sub charts
  ## @extra global.elasticsearch
  ## @param global.elasticsearch.enabled if true, enables elasticsearch for all components
  ## @param global.elasticsearch.external if true, tries to connect to an external elasticsearch
  ## @extra global.elasticsearch.tls
  ## @param global.elasticsearch.tls.enabled enable tls for external elasticsearch
  ## @param global.elasticsearch.tls.existingSecret provide an already existing tls secret for connecting to external elasticsearch
  ## @extra global.elasticsearch.auth
  ## @param global.elasticsearch.auth.username the username for external elasticsearch
  ## @param global.elasticsearch.auth.password the password for external elasticsearch
  ## @param global.elasticsearch.auth.existingSecret you can provide an existing secret for the external elasticsearch password
  ## @param global.elasticsearch.auth.existingSecretKey you can provide an existing secret key for the external elasticsearch password
  elasticsearch:
    enabled: true
    external: false
    tls:
      enabled: false
      existingSecret: ""
    auth:
      username: ""
      password: ""
      existingSecret: ""
      existingSecretKey: "password"
      ## @param  global.elasticsearch.disableExporter DEPRECATED: this value is not needed anymore. Use global.elasticsearch.enabled
    disableExporter: false
    ## @extra global.elasticsearch.url Configuration to configure elasticsearch url
    ## @param global.elasticsearch.url.protocol defines the elasticsearch access protocol.
    ## @param global.elasticsearch.url.host Elasticsearch.host defines the elasticsearch host, ideally the service name inside the namespace
    ## @param global.elasticsearch.url.port Elasticsearch.port defines the elasticsearch port, under which elasticsearch can be accessed
    url:
      protocol: http
      host: "{{ .Release.Name }}-elasticsearch"
      port: 9200
    ## @param global.elasticsearch.clusterName Elasticsearch.clusterName defines the cluster name which is used by Elasticsearch
    clusterName: "elasticsearch"
    ## @param global.elasticsearch.prefix Elasticsearch.prefix defines the prefix which is used by the Zeebe Elasticsearch Exporter to create Elasticsearch indexes
    prefix: zeebe-record
  # Opensearch configuration which is shared between the sub charts
  ## @extra global.opensearch
  ## @param global.opensearch.enabled enabled external opensearch
  ## @param global.opensearch.aws.enabled Enabling AWS IRSA
  ## @extra global.opensearch.tls
  ## @param global.opensearch.tls.enabled enable tls for external opensearch
  ## @param global.opensearch.tls.existingSecret provide an already existing tls secret for connecting to external opensearch
  ## @extra global.opensearch.auth
  ## @param global.opensearch.auth.username the username for external opensearch
  ## @param global.opensearch.auth.password the password for external opensearch
  ## @param global.opensearch.auth.existingSecret you can provide an existing secret for the external opensearch password
  ## @param global.opensearch.auth.existingSecretKey you can provide an existing secret key for the external opensearch password
  opensearch:
    enabled: false
    aws:
      enabled: false
    tls:
      enabled: false
      existingSecret: ""
    auth:
      username: ""
      password: ""
      existingSecret: ""
      existingSecretKey: "password"
    ## @extra global.opensearch.url Configuration to configure opensearch url
    ## @param global.opensearch.url.protocol defines the external opensearch access protocol
    ## @param global.opensearch.url.host defines the external opensearch host, ideally the service name inside the namespace
    ## @param global.opensearch.url.port defines the external opensearch port, under which opensearch can be accessed
    url:
      protocol: https
      host: ""
      port: 443
  ## @param global.zeebeClusterName ZeebeClusterName defines the cluster name for the Zeebe cluster. All Zeebe pods get this prefix in their name and the brokers uses that as cluster name.
  zeebeClusterName: "{{ .Release.Name }}-zeebe"

  # Identity configuration to configure identity specifics on global level, which can be accessed by other components
  identity:
    service:
      ## @param global.identity.service.url
      url: ""
    keycloak:
      # global.identity.keycloak.internal if true, it will configure an extra service with type "ExternalName".
      ## @param global.identity.keycloak.internal It's useful for using existing Keycloak in another namespace with and access it with the combined Ingress.
      internal: false
      ## @param global.identity.keycloak.url can be used incorporate with "identityKeycloak.enabled: false" to use your own Keycloak instead of the one comes with Camunda Helm chart.
      url: {}
        # Example to produce the following URL "https://keycloak.prod.svc.cluster.local:8443":
        # url:
        #   protocol: "https"
        #   host: "keycloak.prod.svc.cluster.local"
        #   port: "8443"
      #  defines the endpoint of Keycloak which varies between Keycloak versions.
      ## @param global.identity.keycloak.contextPath In Keycloak v16.x.x it's hard-coded as '/auth', but in v19.x.x it's '/'.
      contextPath: "/auth"
      ## @param global.identity.keycloak.realm defines Keycloak realm path used for Camunda.
      realm: "/realms/camunda-platform"
      ## @param global.identity.keycloak.auth same as "identityKeycloak.auth" but it's used for existing Keycloak.
      auth: {}
        # identity.keycloak.auth.adminUser can be used to configure admin user to access existing Keycloak.
        # adminUser: ""
        # identity.keycloak.auth.existingSecret can be used to configure existing Secret object which has admin password
        # to access existing Keycloak.
        # existingSecret: ""
        # identity.keycloak.auth.existingSecretKey can be used to configure the key inside existing Secret object
        # which has admin password to access existing Keycloak.
        # existingSecretKey: "admin-password"

    ## @extra global.identity.auth configuration, to configure identity authentication setup
    auth:
      ## @param global.identity.auth.enabled if true, enables the identity authentication otherwise basic-auth will be used on all services.
      enabled: true

      ## @param global.identity.auth.issuer defines the issuer name, which is used by the services to validate the JWT tokens.
      issuer: ""
      ## @param global.identity.auth.issuerBackendUrl defines the issuer backend URL, which is used by the services to validate the JWT tokens in a container to container context.
      issuerBackendUrl: ""
      ## @param global.identity.auth.tokenUrl defines the token URL, which is used by the services to request JWT tokens.
      tokenUrl: ""
      ## @param global.identity.auth.jwksUrl defines the JWKS URL, which is used by the services to validate the JWT tokens.
      jwksUrl: ""
      ## @param global.identity.auth.type defines the type of authentication which should be used. Defaults to Keycloak
      type: "KEYCLOAK"

      #  defines the token issuer (Keycloak) URL, where the services can request JWT tokens.
      # Should be publicly accessible, per default we assume a port-forward to Keycloak (18080) is created before login.
      ## @param global.identity.auth.publicIssuerUrl Can be overwritten if ingress is in use and an external IP is available.
      publicIssuerUrl: "http://localhost:18080/auth/realms/camunda-platform"

      ## @extra global.identity.auth.admin configuration to configure Connectors authentication specifics on global level, which can be accessed by other components
      admin:
        ## @param global.identity.auth.admin.enabled if true, creates the admin client which is used in administration operations if needed.
        enabled: false
        ## @param global.identity.auth.admin.clientId defines the client id.
        clientId: admin
        ## @param global.identity.auth.admin.existingSecret [string,object] can be used to use an own existing secret. If not set a random secret is generated. Can also reference a k8s secret instead of a string literal by specifying global.identity.auth.admin.existingSecret.name
        existingSecret: ""
        ## @param global.identity.auth.admin.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: identity-admin-client-token

      #######################
      # Management Group
      #######################

      ## @extra global.identity.auth.identity configuration to configure Identity authentication specifics on global level, which can be accessed by other components
      identity:
        ## @param global.identity.auth.identity.clientId defines the client id, which is used by Identity in authentication flows.
        clientId: camunda-identity
        ## @param global.identity.auth.identity.audience defines the audience, which is used by Identity.
        audience: camunda-identity-resource-server
        ## @param global.identity.auth.identity.existingSecret can be used to reference an existing secret. This should ONLY be used for an external OIDC provider. If not set, a random secret is generated.
        existingSecret: ""
        ## @param global.identity.auth.identity.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: identity-oidc-client-token
        ## @param global.identity.auth.identity.redirectUrl defines the redirect URL, which is used by the auth platform to access Identity.
        # Should be publicly accessible, the default value works if a port-forward to Identity is created to 8085.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8085"
        ## @param global.identity.auth.identity.initialClaimName defines the initial claim name, which is used by Identity to configure initial mapping rules,
        # defaults to "oid".
        initialClaimName: "oid"
        ## @param global.identity.auth.identity.initialClaimValue defines the initial claim value, which is used by Identity to configure initial mapping rules.
        initialClaimValue: ""

      ## @extra global.identity.auth.console configuration to configure Console authentication specifics on global level, which can be accessed by other components
      console:
        ## @param global.identity.auth.console.clientId defines the client id, which is used by Console in authentication flows.
        clientId: console
        ## @param global.identity.auth.console.audience defines the audience which is used by Console's client API.
        audience: console-api
        ## @param global.identity.auth.console.wellKnown defines the uri for the well known config which is used by Console (optional).
        wellKnown: https://well-known-uri
        ## @param global.identity.auth.console.existingSecret [string,object] can be used to use an own existing secret. If not set a random secret is generated. Can also reference a k8s secret instead of a string literal by specifying global.identity.auth.console.existingSecret.name
        existingSecret: ""
        ## @param global.identity.auth.console.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: identity-console-client-token
        ## @param global.identity.auth.console.redirectUrl defines the root URL which is used by Keycloak to access WebModeler.
        # Should be publicly accessible, the default value works if a port-forward to WebModeler is created to 8080.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8080"

      ## @extra global.identity.auth.webModeler configuration to configure WebModeler authentication specifics on global level, which can be accessed by other components
      webModeler:
        ## @param global.identity.auth.webModeler.clientId defines the client id, which is used by WebModeler in authentication flows.
        clientId: web-modeler
        ## @param global.identity.auth.webModeler.clientApiAudience defines the audience which is used by WebModeler's client API.
        clientApiAudience: web-modeler-api
        ## @param global.identity.auth.webModeler.publicApiAudience defines the audience which is used by WebModeler's public API.
        publicApiAudience: web-modeler-public-api
        ## @param global.identity.auth.webModeler.redirectUrl defines the root URL which is used by Keycloak to access WebModeler.
        # Should be publicly accessible, the default value works if a port-forward to WebModeler is created to 8084.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8084"

      #######################
      # Orchestration Group
      #######################

      ## @extra global.identity.auth.connectors configuration to configure Connectors authentication specifics on global level, which can be accessed by other components
      connectors:
        ## @param global.identity.auth.connectors.clientId defines the client id, which is used by Connectors in authentication flows.
        clientId: connectors
        ## @param global.identity.auth.connectors.existingSecret [string,object] can be used to use an own existing secret. If not set a random secret is generated. Can also reference a k8s secret instead of a string literal by specifying global.identity.auth.connectors.existingSecret.name
        existingSecret: ""
        ## @param global.identity.auth.connectors.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: identity-connectors-client-token

      ## @extra global.identity.auth.core configuration to configure authentication specifics on global level, which can be accessed by other components
      core:
        ## @param global.identity.auth.core.audience defines the audience, which is used by Core.
        audience: core-api
        ## @param global.identity.auth.core.clientId defines the client id, which is used by Core in authentication flows.
        clientId: core
        ## @param global.identity.auth.core.existingSecret [string,object] can be used to use an own existing secret. If not set a random secret is generated. Can also reference a k8s secret instead of a string literal by specifying global.identity.auth.core.existingSecret.name
        existingSecret: ""
        ## @param global.identity.auth.core.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: identity-core-client-token
        ## @param global.identity.auth.core.redirectUrl defines the root (or redirect) URL, which is used by Keycloak to access Tasklist.
        # Should be publicly accessible, the default value works if a port-forward to Core is created to 8082.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8082"
        ## @param global.identity.auth.core.tokenScope defines the token scope, which is used by Core.
        tokenScope: ""

      ## @extra global.identity.auth.optimize configuration to configure Optimize authentication specifics on global level, which can be accessed by other components
      optimize:
        ## @param global.identity.auth.optimize.audience defines the audience, which is used by Optimize.
        audience: optimize-api
        ## @param global.identity.auth.optimize.clientId defines the client id, which is used by Optimize in authentication flows.
        clientId: optimize
        ## @param global.identity.auth.optimize.existingSecret [string,object] can be used to use an own existing secret. If not set a random secret is generated. Can also reference a k8s secret instead of a string literal by specifying global.identity.auth.optimize.existingSecret.name
        existingSecret: ""
        ## @param global.identity.auth.optimize.existingSecretKey defines the key within the existing secret object.
        existingSecretKey: identity-optimize-client-token
        ## @param global.identity.auth.optimize.redirectUrl defines the root (or redirect) URL, which is used by Keycloak to access Optimize.
        # Should be publicly accessible, the default value works if a port-forward to Optimize is created to 8083.
        # Can be overwritten if ingress is in use and an external IP is available.
        redirectUrl: "http://localhost:8083"

  # Multiregion options for Zeebe
  #
  ## WARNING: Customers must develop and test the operational procedure described below in non-production environments based on the framework steps
  # outlined by Camunda before applying them in production setups.
  # Before advancing to production go-live, validating these procedures with Camunda is strongly recommended.
  # Customers are solely responsible for detecting any regional failures and implementing the necessary operational procedure described.
  multiregion:
    ## @skip global.multiregion.regions number of regions that this Camunda Platform instance is stretched across
    regions: 1
    ## @skip global.multiregion.regionId unique id of the region. MUST start at 0 for the computation to work correctly. With 2 regions, you would have region 0 and 1.
    regionId: 0

  ## Document Store Configuration
  ## @extra global.documentStore These parameters are used to configure the document storage backend across all Camunda components.
  documentStore:
    ## @param global.documentStore.activeStoreId The default document store to use. Valid values: inmemory, aws, and gcp.
    activeStoreId: "inmemory"
    type:
      aws:
        ## @param global.documentStore.type.aws.enabled Enable AWS document store configuration.
        enabled: false
        ## @param global.documentStore.type.aws.storeId Custom prefix for AWS. Default will generate env vars containing 'storeId' such as DOCUMENT_STORE_AWS_CLASS.
        storeId: "AWS"
        ## @param global.documentStore.type.aws.region AWS region for the S3 bucket. (example: us-east-1)
        region: ""
        ## @param global.documentStore.type.aws.bucket Name of the AWS S3 bucket.
        bucket: "your-aws-bucket"
       ## @param global.documentStore.type.aws.bucketPath [string, nullable] (Optional) Path/prefix within the S3 bucket.
        # bucketPath: ""
        ## @param global.documentStore.type.aws.bucketTtl [int, nullable] (Optional) Time-to-live for documents in the S3 bucket (number in days).
        # bucketTtl: 0
        ## @param global.documentStore.type.aws.class Fully qualified class name for the AWS document store provider.
        class: "io.camunda.document.store.aws.AwsDocumentStoreProvider"
        ## @param global.documentStore.type.aws.existingSecret Reference to an existing Kubernetes secret containing AWS credentials.
        existingSecret: "aws-credentials"
        ## @param global.documentStore.type.aws.accessKeyIdKey Key within the AWS credentials secret for AWS_ACCESS_KEY_ID.
        accessKeyIdKey: "awsAccessKeyId"
        ## @param global.documentStore.type.aws.secretAccessKeyKey Key within the AWS credentials secret for AWS_SECRET_ACCESS_KEY.
        secretAccessKeyKey: "awsSecretAccessKey"
      gcp:
        ## @param global.documentStore.type.gcp.enabled Enable GCP document store configuration.
        enabled: false
        ## @param global.documentStore.type.gcp.storeId Custom prefix for GCP. Default will generate env vars containing 'storeId' such as DOCUMENT_STORE_GCP_CLASS.
        storeId: "GCP"
        ## @param global.documentStore.type.gcp.bucket Name of the GCP bucket.
        bucket: "your-gcp-bucket"
        ## @param global.documentStore.type.gcp.class Fully qualified class name for the GCP document store provider.
        class: "io.camunda.document.store.gcp.GcpDocumentStoreProvider"
        ## @param global.documentStore.type.gcp.existingSecret Reference to an existing Kubernetes secret containing GCP credentials.
        existingSecret: "gcp-credentials"
        ## @param global.documentStore.type.gcp.credentialsKey Key in the GCP credentials secret that contains the service-account JSON.
        credentialsKey: "service-account.json"
        ## @param global.documentStore.type.gcp.mountPath Mount path for the GCP credentials secret.
        mountPath: "/var/secrets/gcp"
        ## @param global.documentStore.type.gcp.fileName The file name for the GCP credentials JSON.
        fileName: "service-account.json"
      inmemory:
        ## @param global.documentStore.type.inmemory.enabled Enable in-memory document store configuration.
        enabled: true
        ## @param global.documentStore.type.inmemory.storeId Custom prefix for in-memory. Default will generate env vars containing 'storeId' such as DOCUMENT_STORE_INMEMORY_CLASS.
        storeId: "INMEMORY"
        ## @param global.documentStore.type.inmemory.class Fully qualified class name for the in-memory document store provider.
        class: "io.camunda.document.store.inmemory.InMemoryDocumentStoreProvider"


#------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------------------------#
#############################################################################################################
 #     #                                                                   #####                              
 ##   ##   ##   #    #   ##    ####  ###### #    # ###### #    # #####    #     # #####   ####  #    # #####  
 # # # #  #  #  ##   #  #  #  #    # #      ##  ## #      ##   #   #      #       #    # #    # #    # #    # 
 #  #  # #    # # #  # #    # #      #####  # ## # #####  # #  #   #      #  #### #    # #    # #    # #    # 
 #     # ###### #  # # ###### #  ### #      #    # #      #  # #   #      #     # #####  #    # #    # #####  
 #     # #    # #   ## #    # #    # #      #    # #      #   ##   #      #     # #   #  #    # #    # #      
 #     # #    # #    # #    #  ####  ###### #    # ###### #    #   #       #####  #    #  ####   ####  #      
#############################################################################################################
#------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------------------------#


############################################
###
 #  #####  ###### #    # ##### # ##### #   #
 #  #    # #      ##   #   #   #   #    # #
 #  #    # #####  # #  #   #   #   #     #
 #  #    # #      #  # #   #   #   #     #
 #  #    # #      #   ##   #   #   #     #
### #####  ###### #    #   #   #   #     #
############################################
## @section Identity Parameters
# Identity configuration for the identity sub chart.
identity:
  ## @param identity.enabled if true, the identity deployment and its related resources are deployed via a helm release
  #
  # Note: If using Keycloak, Identity is required by WebModeler.
  #       If you don't need WebModeler, make sure to disable both the Identity authentication and the applications by setting:
  #         global.identity.auth.enabled=false
  #         webModeler.enabled=false
  enabled: true

  ## @param identity.fullnameOverride can be used to override the full name of the Identity resources
  fullnameOverride: ""
  ## @param identity.nameOverride can be used to partly override the name of the Identity resources (names will still be prefixed with the release name)
  nameOverride: ""

  ## @extra identity.firstUser configuration to configure properties of the first Identity user, which can be used to access all
  # web applications
  firstUser:
    ## @param identity.firstUser.enabled if true, Identity will seed the first user in Keycloak.
    enabled: true
    ## @param identity.firstUser.username defines the username of the first user, needed to log in into the web applications
    username: demo
    ## @param identity.firstUser.password defines the password of the first user, needed to log in into the web applications
    password: demo
    ## @param identity.firstUser.email defines the email address of the first user; a valid email address is required to use WebModeler
    email: demo@example.org
    ## @param identity.firstUser.firstName defines the first name of the first user; a name is required to use WebModeler
    firstName: Demo
    ## @param identity.firstUser.lastName defines the last name of the first user; a name is required to use WebModeler
    lastName: User
    ## @param identity.firstUser.existingSecret can be used to use an own existing secret for Identity first user.
    existingSecret: camunda-credentials
    ## @param identity.firstUser.existingSecretKey defines the key within the existing secret object.
    existingSecretKey: identity-firstuser-password

  ## @param identity.users configuration to configure properties of the Identity users, which can be used to access web applications.
  users: []

  ## @extra identity.image configuration to configure the identity image specifics
  image:
    ## @param identity.image.registry can be used to set container image registry.
    registry: ""
    ## @param identity.image.repository defines which image repository to use
    repository: camunda/identity
    ## @param identity.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag: 8.8.0-alpha1
    ## @param identity.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @param identity.sidecars can be used to attach extra containers to the identity deployment
  sidecars: []
  ## @param identity.initContainers can be used to set up extra init containers for the application Pod
  initContainers: []
  ## @param identity.fullURL can be used when Ingress is configured (for both multi and single domain setup).
  fullURL: ""

  # Note: Identity cannot be accessed over HTTP if a "contextPath" is configured.
  #       Which means that Identity cannot be configured in combined Ingress without HTTPS.
  #       To use Identity over HTTP, setup a separated Ingress using "identity.ingress" and don't set "contextPath".
  # contextPath: "/identity"
  ## @param identity.contextPath can be used to make Identity web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @param identity.podAnnotations can be used to define extra Identity pod annotations
  podAnnotations: {}
  ## @param identity.podLabels can be used to define extra Identity pod labels
  podLabels: {}

  ## @extra identity.logging configuration for the identity logging. This template will be directly included in the identity configuration YAML file
  ## @param identity.logging.level.ROOT
  ## @param identity.logging.level.io.camunda.identity https://docs.camunda.io/docs/next/self-managed/identity/user-guide/configuration/configure-logging/#general-configuration-options
  logging:
    level:
      ROOT: DEBUG
      io.camunda.identity: DEBUG

  ## @extra identity.service configuration to configure the identity service.
  service:
    ## @param identity.service.annotations can be used to define annotations, which will be applied to the identity service
    annotations: {}
    ## @param identity.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param identity.service.port defines the port of the service on which the identity application will be available
    port: 80
    ## @param identity.service.metricsPort defines the port of the service on which the identity metrics will be available
    metricsPort: 82
    ## @param identity.service.metricsName defines the name of the service on which the identity metrics will be available
    metricsName: metrics

  ## @extra identity.podSecurityContext defines the security options the Identity pod should be run with
  podSecurityContext:
    ## @param identity.podSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param identity.podSecurityContext.fsGroup
    fsGroup: 1001
    ## @extra identity.podSecurityContext.seccompProfile
    seccompProfile:
      ## @param identity.podSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra identity.containerSecurityContext defines the security options the Identity container should be run with
  containerSecurityContext:
    ## @param identity.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param identity.containerSecurityContext.privileged
    privileged: false
    ## @param identity.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param identity.containerSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param identity.containerSecurityContext.runAsUser
    runAsUser: 1001
    ## @extra identity.containerSecurityContext.seccompProfile
    seccompProfile:
      ## @param identity.containerSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra identity.startupProbe configuration
  startupProbe:
    ## @param identity.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param identity.startupProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param identity.startupProbe.probePath defines the startup probe route used on the app
    probePath: /actuator/health
    ## @param identity.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
    ## @param identity.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param identity.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param identity.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param identity.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra identity.readinessProbe configuration
  readinessProbe:
    ## @param identity.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param identity.readinessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param identity.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /actuator/health
    ## @param identity.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
    ## @param identity.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param identity.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param identity.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param identity.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra identity.livenessProbe configuration
  livenessProbe:
    ## @param identity.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param identity.livenessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param identity.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /actuator/health
    ## @param identity.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param identity.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param identity.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param identity.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param identity.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## Metrics configuration
  metrics:
    ## @param identity.metrics.prometheus Prometheus metrics endpoint
    prometheus: /actuator/prometheus

  ## @param identity.nodeSelector can be used to define on which nodes the Identity pods should run
  nodeSelector: {}
  ## @param identity.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @param identity.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

  ## @extra identity.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @param identity.resources.requests.memory
  ## @param identity.resources.limits.cpu
  ## @param identity.resources.requests.cpu
  ## @param identity.resources.limits.memory
  resources:
    requests:
      cpu: 600m
      memory: 400Mi
    limits:
      cpu: 2000m
      memory: 2Gi

  ## @param identity.env can be used to set extra environment variables in each identity container. See the documentation https://docs.camunda.io/docs/self-managed/identity/deployment/configuration-variables/ for more details.
  env: []
  ## @param identity.envFrom list of environment variables to import from configMapRef and secretRef
  envFrom: []
  ## @param identity.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  ## @param identity.extraVolumes can be used to define extra volumes for the identity pods, useful for tls and self-signed certificates
  extraVolumes: []
  ## @param identity.extraVolumeMounts can be used to mount extra volumes for the identity pods, useful for tls and self-signed certificates
  extraVolumeMounts: []

  ## @extra identity.serviceAccount configuration for the service account where the identity pods are assigned to
  serviceAccount:
    ## @param identity.serviceAccount.enabled if true, enables the identity service account
    enabled: true
    ## @param identity.serviceAccount.name can be used to set the name of the identity service account
    name: ""
    ## @param identity.serviceAccount.annotations can be used to set the annotations of the identity service account
    annotations: {}
    ## @param identity.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: true

  ## External PostgreSQL configuration
  ## All of these values are only used when postgresql.enabled is set to false
  ## @param identity.externalDatabase.enabled
  ## @param identity.externalDatabase.host Database host
  ## @param identity.externalDatabase.port Database port number
  ## @param identity.externalDatabase.username Non-root username
  ## @param identity.externalDatabase.password Password for the non-root username
  ## @param identity.externalDatabase.database The database name
  ## @param identity.externalDatabase.existingSecret Name of an existing secret resource containing the database credentials
  ## @param identity.externalDatabase.existingSecretPasswordKey Name of an existing secret key containing the database credentials
  ##
  externalDatabase:
    enabled: false
    host: ""
    port: 5432
    username: ""
    database: ""
    password: ""
    existingSecret: ""
    existingSecretPasswordKey: ""

  ## @param identity.configuration if specified, contents will be used as the application.yaml
  configuration: ""
  ## @param identity.extraConfiguration if specified, contents will be used for any extra configuration files such as the log4j2.xml
  extraConfiguration: {}
  ## @param identity.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
  dnsPolicy: ""
  ## @param identity.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  dnsConfig: {}

# Identity.
#####   ####   ####  #####  ####  #####  ######  ####   ####  #
#    # #    # #        #   #    # #    # #      #      #    # #
#    # #    #  ####    #   #      #    # #####   ####  #    # #
#####  #    #      #   #   #  ### #####  #           # #  # # #
#      #    # #    #   #   #    # #   #  #      #    # #   #  #
#       ####   ####    #    ####  #    # ######  ####   ### # ######
## @section Identity - PostgreSQL Parameters
## @extra identityPostgresql configuration for the PostgreSQL dependency chart used by Identity. For more details, check [Bitnami package for PostgreSQL](https://artifacthub.io/packages/helm/bitnami/postgresql#parameters) documentation.
identityPostgresql:
  ## @param identityPostgresql.enabled Enable Identity PostgreSQL Helm chart. Required for Multi-Tenancy.
  ##
  enabled: false
  ## @extra identityPostgresql.global.compatibility Compatibility adaptations for Kubernetes platforms
  global:
    ## Compatibility adaptations for Kubernetes platforms
    ##
    compatibility:
      ## Compatibility adaptations for Openshift
      ##
      openshift:
        ## @param identityPostgresql.global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: force (perform the adaptation always), disabled (do not perform adaptation)
        ##
        adaptSecurityContext: "{{ .Values.global.compatibility.openshift.adaptSecurityContext | default \"disabled\" }}"
  # https://hub.docker.com/r/bitnami/postgresql/tags
  ## @param identityPostgresql.image.repository PostgreSQL repo
  ## @param identityPostgresql.image.tag PostgreSQL image tag
  ##
  image:
    repository: bitnami/postgresql
    tag: 15.10.0-debian-12-r2
  ## @param identityPostgresql.nameOverride the name used for Identity PostgreSQL.
  ##
  nameOverride: identity-postgresql
  auth:
    ## @param identityPostgresql.auth.username Non-root username
    ##
    username: identity
    ## @param identityPostgresql.auth.database The database name
    ##
    database: identity
    ## @param identityPostgresql.auth.password Password for the non-root username
    ##
    password: ""
    ## @param identityPostgresql.auth.existingSecret Name of an existing secret resource containing the database credentials
    ##
    existingSecret: ""
    secretKeys:
      ## @param identityPostgresql.auth.secretKeys.adminPasswordKey defines the key within the existing secret object for PostgreSQL admin.
      adminPasswordKey: "postgres-password"
      ## @param identityPostgresql.auth.secretKeys.userPasswordKey defines the key within the existing secret object for PostgreSQL user.
      userPasswordKey: "password"

# Identity.
#    # ###### #   #  ####  #       ####    ##   #    #
#   #  #       # #  #    # #      #    #  #  #  #   #
####   #####    #   #      #      #    # #    # ####
#  #   #        #   #      #      #    # ###### #  #
#   #  #        #   #    # #      #    # #    # #   #
#    # ######   #    ####  ######  ####  #    # #    #
## @section Identity - Keycloak Parameters
## @extra identityKeycloak configuration, for the Keycloak dependency chart which is used by Identity. For more details, check [Bitnami package for Keycloak](https://artifacthub.io/packages/helm/bitnami/keycloak#parameters) documentation.
identityKeycloak:
  ## @param identityKeycloak.enabled Enable Identity Keycloak Helm chart. It is used incorporate with "global.identity.keycloak" to use your own Keycloak instead of the one comes with Camunda Helm chart
  enabled: true
  ## @extra identityKeycloak.global.compatibility Compatibility adaptations for Kubernetes platforms
  global:
    ## Compatibility adaptations for Kubernetes platforms
    ##
    compatibility:
      ## Compatibility adaptations for Openshift
      ##
      openshift:
        ## @param identityKeycloak.global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: force (perform the adaptation always), disabled (do not perform adaptation)
        ##
        adaptSecurityContext: "{{ .Values.global.compatibility.openshift.adaptSecurityContext | default \"disabled\" }}"
  
  ## @param identityKeycloak.nameOverride the name used for Keycloak.
  nameOverride: "keycloak"

  ## @extra identityKeycloak.image configuration.
  # https://hub.docker.com/r/bitnami/keycloak/tags
  image:
    ## @param identityKeycloak.image.repository image repo
    repository: camunda/keycloak
    ## @param identityKeycloak.image.tag image tag
    tag: 25.0.6

  ## @extra identityKeycloak.postgresql configuration.
  postgresql:
    # https://hub.docker.com/r/bitnami/postgresql/tags
    image:
      ## @param identityKeycloak.postgresql.image.repository image repo
      repository: bitnami/postgresql
      ## @param identityKeycloak.postgresql.image.tag image tag
      tag: 15.10.0-debian-12-r2
    auth:
      ## @param identityKeycloak.postgresql.auth.existingSecret defines the existing secret resource containing the database credentials
      existingSecret: camunda-credentials
      secretKeys:
        ## @param identityKeycloak.postgresql.auth.secretKeys.adminPasswordKey defines the key within the existing secret object for PostgreSQL admin.
        adminPasswordKey: "identity-keycloak-postgresql-admin-password"
        ## @param identityKeycloak.postgresql.auth.secretKeys.userPasswordKey defines the key within the existing secret object for PostgreSQL user.
        userPasswordKey: "identity-keycloak-postgresql-user-password"
    primary:
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.enabled
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.privileged
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.readOnlyRootFilesystem
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.allowPrivilegeEscalation
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.runAsNonRoot
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.runAsUser
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.capabilities.drop
      ## @param identityKeycloak.postgresql.primary.containerSecurityContext.seccompProfile.type
      containerSecurityContext:
        enabled: true
        privileged: false
        readOnlyRootFilesystem: true
        allowPrivilegeEscalation: false
        runAsNonRoot: true
        runAsUser: 1001
        capabilities:
          drop: ["ALL"]
        seccompProfile:
          type: RuntimeDefault
      ## @param identityKeycloak.postgresql.primary.podSecurityContext.enabled
      ## @param identityKeycloak.postgresql.primary.podSecurityContext.runAsNonRoot
      ## @param identityKeycloak.postgresql.primary.podSecurityContext.fsGroup
      podSecurityContext:
        enabled: true
        runAsNonRoot: true
        fsGroup: 1001
  # Keycloak.proxy defines the proxy mode depends on the TLS termination in your environment.
  # Docs: https://www.keycloak.org/server/reverseproxy
  ## @param identityKeycloak.proxy keycloak proxy
  proxy: edge

  ## @extra identityKeycloak.tls can be used to enable TLS encryption. Required for HTTPs traffic.
  tls:
  ## @param identityKeycloak.tls.enabled enabling tls
    enabled: false

  # NOTE: Since Helm v3 (latest checked 3.10.x) doesn't merge lists with custom values files, then you will need to
  # add this to your own values file if you override any of "extraVolumes", "initContainers", or "extraVolumeMounts".
  ## @skip identityKeycloak.extraVolumes [object] Extra volumes for keycloak
  ## @skip identityKeycloak.extraVolumes[0].name
  ## @skip identityKeycloak.extraVolumes[0].emptyDir
  ## @skip identityKeycloak.extraVolumes[1].name
  ## @skip identityKeycloak.extraVolumes[1].emptyDir
  extraVolumes:
  - name: data-tmp
    emptyDir: {}
  ## @param identityKeycloak.extraVolumeMounts[0].name
  ## @param identityKeycloak.extraVolumeMounts[0].mountPath
  extraVolumeMounts:
  - name: data-tmp
    mountPath: /opt/bitnami/keycloak/data/tmp

  ## @param identityKeycloak.containerSecurityContext.privileged
  ## @param identityKeycloak.containerSecurityContext.readOnlyRootFilesystem
  ## @param identityKeycloak.containerSecurityContext.allowPrivilegeEscalation
  ## @param identityKeycloak.containerSecurityContext.runAsNonRoot
  ## @param identityKeycloak.containerSecurityContext.runAsUser
  ## @param identityKeycloak.containerSecurityContext.capabilities.drop
  ## @param identityKeycloak.containerSecurityContext.seccompProfile.type
  containerSecurityContext:
    privileged: false
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    runAsNonRoot: true
    runAsUser: 1001
    capabilities:
      drop: ["ALL"]
    seccompProfile:
      type: RuntimeDefault
  ## @param identityKeycloak.podSecurityContext.runAsNonRoot
  ## @param identityKeycloak.podSecurityContext.fsGroup
  podSecurityContext:
    runAsNonRoot: true
    fsGroup: 1001
  ## @param identityKeycloak.httpRelativePath defines the context for Keycloak. This config is valid for Keycloak v19.x.x only
  # where in Keycloak v16.x.x it's hard-coded as '/auth', but in v19.x.x it's configurable.
  # NOTE: This should be the same as ".Values.global.identity.keycloak.contextPath" plus a trailing slash,
  # but it cannot be referenced directly because of a bug in Helm (tested with Helm v3.9.3).
  # NOTE: In Keycloak v23, accessing this path without the trailing slash will return "Internal Server Error".
  httpRelativePath: /auth/
  ## @extra identityKeycloak.extraEnvVars
  ## @param identityKeycloak.extraEnvVars[0].name
  ## @param identityKeycloak.extraEnvVars[0].value
  extraEnvVars:
  # KEYCLOAK_PROXY_ADDRESS_FORWARDING can be used with Ingress that has SSL Termination. It will be "true" if the TLS
  # in global Ingress is enabled, but it could be overwritten with separate Ingress setup.
  - name: KEYCLOAK_PROXY_ADDRESS_FORWARDING
    value: "{{ .Values.global.ingress.tls.enabled }}"

  # under "global.ingress" is enabled. However, it's possible to setup Keycloak on a separate Ingress if needed.
  # For more details: https://github.com/bitnami/charts/tree/main/bitnami/keycloak#configure-ingress
  ingress:
    ## @param identityKeycloak.ingress.enabled can be used enable ingress record generation for Keycloak.
    enabled: false
    ## @param identityKeycloak.ingress.tls can be used to enable TLS configuration for the host defined at ingress.hostname parameter.
    tls: false
    ## @param identityKeycloak.ingress.extraTls configuration for additional hostnames to be covered with this ingress record.
    extraTls: []
    ## @param identityKeycloak.ingress.annotations [object] configures annotations to be applied to the ingress record.
    annotations:
    ## @skip identityKeycloak.ingress.annotations.nginx.ingress.kubernetes.io/proxy-buffer-size
      nginx.ingress.kubernetes.io/proxy-buffer-size: '128k'
      nginx.ingress.kubernetes.io/proxy-buffering: 'on'
    ## @param identityKeycloak.ingress.pathType defines Ingress path type.
    pathType: Prefix

  ## @extra identityKeycloak.service configuration, to configure the service which is deployed along with keycloak
  service:
    ## @param identityKeycloak.service.type can be set to change the service type.
    # We use clusterIP for keycloak service, since per default LoadBalancer is used, which is not supported on all cloud providers.
    # This might prevent scheduling of the service.
    type: ClusterIP
  ## Keycloak authentication parameters
  ## ref: https://github.com/bitnami/bitnami-docker-keycloak#admin-credentials
  ##
  ## @extra identityKeycloak.auth uses the secrets generated by keycloak, to access keycloak.
  auth:
    ## @param identityKeycloak.auth.adminUser defines the keycloak administrator user
    adminUser: admin
    ## @param identityKeycloak.auth.existingSecret can be used to reuse an existing secret containing authentication information.
    # See https://docs.bitnami.com/kubernetes/apps/keycloak/configuration/manage-passwords/ for more details.
    existingSecret: camunda-credentials
    ## @param identityKeycloak.auth.passwordSecretKey defines the key within the existing secret object.
    passwordSecretKey: identity-keycloak-admin-password


#################################################
 #####
#     #  ####  #    #  ####   ####  #      ######
#       #    # ##   # #      #    # #      #
#       #    # # #  #  ####  #    # #      #####
#       #    # #  # #      # #    # #      #
#     # #    # #   ## #    # #    # #      #
 #####   ####  #    #  ####   ####  ###### ######
#################################################

## @section Console Parameters
## @extra console configuration for the Console.
console:
  ## @param console.enabled if true, the Console deployment and its related resources are deployed via a helm release
  enabled: false

  ## @param console.configuration Configuration passed directly to Console as YAML file. More details on [Console official documenations](https://docs.camunda.io/docs/self-managed/console-deployment/configuration/)
  configuration: ""
  ##@param console.overrideConfiguration When populated, it will override the configuration passed to Console, either auto-generated configuration or passed via `console.configuration`
  overrideConfiguration: ""

  ## console.image configuration to configure the Console image specifics
  # https://hub.docker.com/r/camunda/console/tags
  image:
    ## @param console.image.registry can be used to set container image registry.
    registry: ""
    ## @param console.image.repository defines which image repository to use
    repository: camunda/console
    ## @param console.image.tag can be used to set the Docker image tag for the Console image (overwrites global.image.tag)
    tag: 8.8.0-alpha2
    ## @param console.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @param console.sidecars can be used to attach extra containers to the console deployment
  sidecars: []

  ## @param console.replicas Number of Console replicas
  replicas: 1

  ## console.tls Configure the Console TLS options
  tls:
    ## @param console.tls.enabled Enable TLS traffic for console
    enabled: false
    ## @param console.tls.existingSecret The name of the existing secret that contains the TLS certificates. Each key of the secret corresponds to a certificate filename, and each value of a key corresponds to the content of the certificate file.
    existingSecret: ""
    ## @param console.tls.certKeyFilename Certificate Key filename
    certKeyFilename: ""

  ## console.keycloak configuration to configure Keycloak authentication settings.
  keycloak:
    ## @param console.keycloak.realm Specifies the Keycloak realm used for authentication.
    realm: "camunda-platform"

  ## @param console.contextPath can be used to make Console web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @param console.initContainers can be used to set up extra init containers for the application Pod
  initContainers: []

  ## @param console.podAnnotations can be used to define extra Console pod annotations
  podAnnotations: {}
  ## @param console.podLabels can be used to define extra Console pod labels
  podLabels: {}

  ## @param console.logging configuration for the Console logging. This template will be directly included in the configuration YAML file
  logging: {}

  ## console.service configuration to configure the Console service.
  service:
    ## @param console.service.annotations can be used to define annotations, which will be applied to the Console service
    annotations: {}
    ## @param console.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param console.service.port defines the port number where the web application will be available
    port: 80
    ## @param console.service.serverName defines the port name where the web application will be available
    serverName: http
    ## @param console.service.managementPort defines the management port used to access metrics and app status
    managementPort: 9100

  ## console.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @param console.resources.requests.memory
  ## @param console.resources.limits.cpu
  ## @param console.resources.limits.memory
  ## @param console.resources.requests.cpu
  resources:
    requests:
      cpu: 1
      memory: 1Gi
    limits:
      cpu: 2
      memory: 2Gi

  ## @param console.env can be used to set extra environment variables in each app container
  env: []
  ## @param console.envFrom list of environment variables to import from configMapRef and secretRef
  envFrom: []
  ## @param console.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  ## @param console.extraVolumes can be used to define extra volumes for the Console pods, useful for TLS and self-signed certificates
  extraVolumes: []
  ## @param console.extraVolumeMounts can be used to mount extra volumes for the Console pods, useful for TLS and self-signed certificates
  extraVolumeMounts: []

  ## console.startupProbe configuration
  startupProbe:
    ## @param console.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param console.startupProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param console.startupProbe.probePath defines the startup probe route used on the app
    probePath: /health/readiness
    ## @param console.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param console.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param console.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param console.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param console.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## console.readinessProbe configuration
  readinessProbe:
    ## @param console.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param console.readinessProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param console.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /health/readiness
    ## @param console.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param console.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param console.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param console.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param console.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## console.livenessProbe configuration
  livenessProbe:
    ## @param console.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param console.livenessProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param console.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /health/liveness
    ## @param console.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param console.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param console.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param console.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param console.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## console.metrics configuration
  metrics:
    ## @param console.metrics.prometheus Prometheus metrics endpoint
    prometheus: /prometheus

  ## console.serviceAccount configuration for the service account where the Console pods are assigned to
  serviceAccount:
    ## @param console.serviceAccount.enabled if true, enables the Console service account
    enabled: true
    ## @param console.serviceAccount.name can be used to set the name of the Console service account
    name: ""
    ## @param console.serviceAccount.annotations can be used to set the annotations of the service account
    annotations: {}
    ## @param console.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: false

  ## @extra console.podSecurityContext defines the security options the Console broker pod should be run with
  podSecurityContext:
    ## @param console.podSecurityContext.runAsNonRoot run as non root
    runAsNonRoot: true
    ## @param console.podSecurityContext.fsGroup
    fsGroup: 1001
    ## @extra console.podSecurityContext.seccompProfile
    seccompProfile:
    ## @param console.podSecurityContext.seccompProfile.type
      type: RuntimeDefault

  # ContainerSecurityContext defines the security options the Console broker container should be run with
  containerSecurityContext:
    ## @param console.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param console.containerSecurityContext.privileged
    privileged: false
    ## @param console.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param console.containerSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param console.containerSecurityContext.runAsUser
    runAsUser: 1001
    ## @extra console.containerSecurityContext.seccompProfile
    seccompProfile:
    ## @param console.containerSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @param console.nodeSelector can be used to define on which nodes the Console pods should run
  nodeSelector: {}
  ## @param console.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @param console.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}
  ## @param console.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
  dnsPolicy: ""
  ## @param console.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  dnsConfig: {}

#######################################################################
#     #               #     #
#  #  # ###### #####  ##   ##  ####  #####  ###### #      ###### #####
#  #  # #      #    # # # # # #    # #    # #      #      #      #    #
#  #  # #####  #####  #  #  # #    # #    # #####  #      #####  #    #
#  #  # #      #    # #     # #    # #    # #      #      #      #####
#  #  # #      #    # #     # #    # #    # #      #      #      #   #
 ## ##  ###### #####  #     #  ####  #####  ###### ###### ###### #    #
#######################################################################
## @section WebModeler Parameters
# WebModeler configuration of the WebModeler deployment
webModeler:
  ## @param webModeler.enabled if true, the WebModeler deployment and its related resources are deployed via a helm release
  enabled: false

  ## @param webModeler.fullnameOverride can be used to override the full name of the WebModeler resources
  fullnameOverride: ""
  ## @param webModeler.nameOverride can be used to partly override the name of the WebModeler resources (names will still be prefixed with the release name)
  nameOverride: ""

  ## @extra webModeler.image configuration of the WebModeler Docker images
  image:
    ## @param webModeler.image.registry can be used to set the Docker registry for the WebModeler images (overwrites global.image.registry)
    registry: ""
    ## @param webModeler.image.tag can be used to set the Docker image tag for the WebModeler images (overwrites global.image.tag)
    # renovate: datasource=docker depName=camunda/web-modeler-restapi
    tag: 8.8.0-alpha1
    ## @param webModeler.image.pullSecrets can be used to configure image pull secrets, see https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  # Note: The WebSocket application will be exposed on the configured path suffixed with "-ws", e.g. "/modeler-ws"
  # contextPath: "/modeler"
  ## @param webModeler.contextPath can be used to make WebModeler available on a custom sub-path. This is mainly used to run the Camunda web applications under a single domain.
  contextPath: ""

  # WebModeler.
  ######                         #    ######  ###
  #     # ######  ####  #####   # #   #     #  #
  #     # #      #        #    #   #  #     #  #
  ######  #####   ####    #   #     # ######   #
  #   #   #           #   #   ####### #        #
  #    #  #      #    #   #   #     # #        #
  #     # ######  ####    #   #     # #       ###
  ## @section WebModeler - RestAPI Parameters
  ## @extra webModeler.restapi configuration of the WebModeler restapi component
  restapi:
    ## @extra webModeler.restapi.image configuration of the restapi Docker image
    image:
      ## @param webModeler.restapi.image.repository defines which image repository to use for the restapi Docker image
      repository: camunda/web-modeler-restapi

    ## @param webModeler.restapi.sidecars can be used to attach extra containers to the restapi deployment
    sidecars: []
    ## @param webModeler.restapi.initContainers can be used to set up extra init containers for the application Pod
    initContainers: []

    ## @extra webModeler.restapi.externalDatabase can be used to configure a connection to an external database; will only be applied if the postgresql dependency chart is disabled (with `postgresql.enabled=false`)
    # Note: Currently, the only supported database system is PostgreSQL.
    externalDatabase:
      ## @param webModeler.restapi.externalDatabase.url defines the JDBC url of the database instance
      url: ""
      ## @param webModeler.restapi.externalDatabase.user defines the database user
      user: ""
      ## @param webModeler.restapi.externalDatabase.password can be used to provide the database user's password; ignored if `webModeler.restapi.externalDatabase.existingSecret` is set
      password: ""
      ## @param webModeler.restapi.externalDatabase.existingSecret can be used to provide the name of an existing secret resource containing the database password
      existingSecret: ""
      ## @param webModeler.restapi.externalDatabase.existingSecretPasswordKey can be used to provide the name of an existing secret key containing the database password
      existingSecretPasswordKey: "database-password"

    ## @extra webModeler.restapi.mail configuration for emails sent by WebModeler
    mail:
      ## @param webModeler.restapi.mail.smtpHost defines the host name of the SMTP server to be used by WebModeler
      smtpHost: ""
      ## @param webModeler.restapi.mail.smtpPort defines the port number of the SMTP server
      smtpPort: 587
      ## @param webModeler.restapi.mail.smtpUser can be used to provide a user for the SMTP server
      smtpUser: ""
      ## @param webModeler.restapi.mail.smtpPassword can be used to provide a password for the SMTP server; ignored if `webModeler.restapi.mail.existingSecret` is set
      smtpPassword: ""
      ## @param webModeler.restapi.mail.smtpTlsEnabled if true, enforces TLS encryption for SMTP connections (using STARTTLS)
      smtpTlsEnabled: true
      ## @param webModeler.restapi.mail.existingSecret can be used to provide the name of an existing secret resource containing the SMTP password
      existingSecret: ""
      ## @param webModeler.restapi.mail.existingSecretPasswordKey can be used to provide the name of an existing secret key containing the SMTP password
      existingSecretPasswordKey: "smtp-password"
      ## @param webModeler.restapi.mail.fromAddress defines the email address that will be displayed as the sender of emails sent by WebModeler
      # NOTE: This value is mandatory.
      fromAddress: ""
      ## @param webModeler.restapi.mail.fromName defines the name that will be displayed as the sender of emails sent by WebModeler
      fromName: "Camunda 8"

    ## @param webModeler.restapi.clusters can be used to configure Camunda 8 clusters that will be available in Web Modeler (will override default cluster configuration that is used if `core.enabled=true`)
    clusters: []
    #  - id: "default-cluster"
    #    name: "Default cluster"
    #    version: "8.8.0"
    #    authentication: "OAUTH"
    #    url:
    #      zeebe:
    #        grpc: "grpc://camunda-platform-core:26500"
    #        rest: "http://camunda-platform-core:8080/v1"
    #      operate: "http://camunda-platform-core:8080/v1"
    #      tasklist: "http://camunda-platform-core:8080/tasklist"

    ## @param webModeler.restapi.podAnnotations can be used to define extra restapi pod annotations
    podAnnotations: {}
    ## @param webModeler.restapi.podLabels can be used to define extra restapi pod labels
    podLabels: {}

    ## @extra webModeler.restapi.logging configuration for the restapi logging. This template will be directly included in the webModeler.restapi configuration YAML file
    ## @param webModeler.restapi.logging.level.io.camunda.modeler https://docs.camunda.io/docs/next/self-managed/modeler/web-modeler/troubleshooting/troubleshoot-zeebe-connection/#how-can-i-debug-log-grpc--zeebe-communication
    ## @param webModeler.restapi.logging.level.io.grpc
    logging:
      level:
        io.camunda.modeler: DEBUG
        io.grpc: TRACE

    ## @param webModeler.restapi.env can be used to set extra environment variables in each restapi container
    env: []
    ## @param webModeler.restapi.envFrom list of environment variables to import from configMapRef and secretRef
    envFrom: []
    ## @param webModeler.restapi.command can be used to override the default command provided by the container image, see https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
    command: []
    ## @param webModeler.restapi.extraVolumes can be used to define extra volumes for the restapi pods, useful for TLS and self-signed certificates
    extraVolumes: []
    ## @param webModeler.restapi.extraVolumeMounts can be used to mount extra volumes for the restapi pods, useful for TLS and self-signed certificates
    extraVolumeMounts: []

    ## @extra webModeler.restapi.podSecurityContext can be used to define the security options the restapi pod should be run with
    podSecurityContext:
      ## @param webModeler.restapi.podSecurityContext.runAsNonRoot
      ## @param webModeler.restapi.podSecurityContext.fsGroup
      runAsNonRoot: true
      fsGroup: 1001
      ## @extra webModeler.restapi.podSecurityContext.seccompProfile
      seccompProfile:
      ## @param webModeler.restapi.podSecurityContext.seccompProfile.type
        type: RuntimeDefault
    ## @extra webModeler.restapi.containerSecurityContext can be used to define the security options the restapi container should be run with
    ## @param webModeler.restapi.containerSecurityContext.privileged
    ## @param webModeler.restapi.containerSecurityContext.readOnlyRootFilesystem
    ## @param webModeler.restapi.containerSecurityContext.allowPrivilegeEscalation
    ## @param webModeler.restapi.containerSecurityContext.runAsNonRoot
    ## @param webModeler.restapi.containerSecurityContext.runAsUser
    containerSecurityContext:
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      ## @extra webModeler.restapi.containerSecurityContext.seccompProfile
      seccompProfile:
      ## @param webModeler.restapi.containerSecurityContext.seccompProfile.type
        type: RuntimeDefault

    ## @extra webModeler.restapi.startupProbe configuration of the restapi startup probe
    startupProbe:
      ## @param webModeler.restapi.startupProbe.enabled if true, the startup probe will be enabled for the restapi container
      enabled: false
      ## @param webModeler.restapi.startupProbe.scheme defines the startup probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.restapi.startupProbe.probePath defines the HTTP endpoint used for the startup probe
      probePath: /health/liveness
      ## @param webModeler.restapi.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 30
      ## @param webModeler.restapi.startupProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.restapi.startupProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.restapi.startupProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.restapi.startupProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.restapi.readinessProbe configuration of the restapi readiness probe
    readinessProbe:
      ## @param webModeler.restapi.readinessProbe.enabled if true, the readiness probe will be enabled for the restapi container
      enabled: true
      ## @param webModeler.restapi.readinessProbe.scheme defines the startup probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.restapi.readinessProbe.probePath defines the HTTP endpoint used for the readiness probe
      probePath: /health/readiness
      ## @param webModeler.restapi.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 30
      ## @param webModeler.restapi.readinessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.restapi.readinessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.restapi.readinessProbe.failureThreshold defines when the probe is considered failed so the Pod will be marked unready
      failureThreshold: 5
      ## @param webModeler.restapi.readinessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.restapi.livenessProbe configuration of the restapi liveness probe
    livenessProbe:
      ## @param webModeler.restapi.livenessProbe.enabled if true, the liveness probe will be enabled for the restapi container
      enabled: false
      ## @param webModeler.restapi.livenessProbe.scheme defines the startup probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.restapi.livenessProbe.probePath defines the HTTP endpoint used for the liveness probe
      probePath: /health/liveness
      ## @param webModeler.restapi.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 30
      ## @param webModeler.restapi.livenessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.restapi.livenessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.restapi.livenessProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.restapi.livenessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## Metrics configuration
    metrics:
      ## @param webModeler.restapi.metrics.prometheus Prometheus metrics endpoint
      prometheus: /metrics

    ## @param webModeler.restapi.nodeSelector can be used to select the nodes the restapi pods should run on
    nodeSelector: {}
    ## @param webModeler.restapi.tolerations can be used to define pod tolerations, see https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
    tolerations: []
    ## @param webModeler.restapi.affinity can be used to define pod affinity or anti-affinity, see https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
    affinity: {}

    ## @extra webModeler.restapi.resources configuration of resource requests and limits for the container, see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
    ## @param webModeler.restapi.resources.requests.cpu
    ## @param webModeler.restapi.resources.requests.memory
    ## @param webModeler.restapi.resources.limits.cpu
    ## @param webModeler.restapi.resources.limits.memory
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
      limits:
        cpu: 1000m
        memory: 2Gi

    ## @extra webModeler.restapi.service configuration of the WebModeler restapi service
    service:
      ## @param webModeler.restapi.service.annotations can be used to define annotations which will be applied to the service
      annotations: {}
      ## @param webModeler.restapi.service.type defines the type of the service, see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
      type: ClusterIP
      ## @param webModeler.restapi.service.port defines the default port of the service
      port: 80
      ## @param webModeler.restapi.service.managementPort defines the management port of the service
      managementPort: 8091

    ## @param webModeler.restapi.configuration if specified, contents will be used as the application.yaml
    configuration: ""
    ## @param webModeler.restapi.extraConfiguration if specified, contents will be used for any extra configuration files such as log4j2.xml
    extraConfiguration: {}
    ## @param webModeler.restapi.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
    dnsPolicy: ""
    ## @param webModeler.restapi.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
    dnsConfig: { }

  # WebModeler.
  #    # ###### #####    ##   #####  #####
  #    # #      #    #  #  #  #    # #    #
  #    # #####  #####  #    # #    # #    #
  # ## # #      #    # ###### #####  #####
  ##  ## #      #    # #    # #      #
  #    # ###### #####  #    # #      #
  ## @section WebModeler - WebApp Parameters
  ## @extra webModeler.webapp. configuration of the WebModeler webapp component
  webapp:
    ## @extra webModeler.webapp.image configuration of the webapp Docker image
    image:
      ## @param webModeler.webapp.image.repository defines which image repository to use for the webapp Docker image
      repository: camunda/web-modeler-webapp

    ## @param webModeler.webapp.sidecars can be used to attach extra containers to the modeler webapp deployment
    sidecars: []
    ## @param webModeler.webapp.initContainers can be used to set up extra init containers for the application Pod
    initContainers: []

    ## @param webModeler.webapp.podAnnotations can be used to define extra webapp pod annotations
    podAnnotations: {}
    ## @param webModeler.webapp.podLabels can be used to define extra webapp pod labels
    podLabels: {}

    ## @param webModeler.webapp.env can be used to set extra environment variables in each webapp container
    env: []
    ## @param webModeler.webapp.envFrom list of environment variables to import from configMapRef and secretRef
    envFrom: []
    ## @param webModeler.webapp.command can be used to override the default command provided by the container image, see https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
    command: []
    ## @param webModeler.webapp.extraVolumes can be used to define extra volumes for the webapp pods, useful for TLS and self-signed certificates
    extraVolumes: []
    ## @param webModeler.webapp.extraVolumeMounts can be used to mount extra volumes for the webapp pods, useful for TLS and self-signed certificates
    extraVolumeMounts: []

    ## @extra webModeler.webapp.podSecurityContext can be used to define the security options the webapp pod should be run with
    ## @param webModeler.webapp.podSecurityContext.runAsNonRoot
    ## @param webModeler.webapp.podSecurityContext.fsGroup
    podSecurityContext:
      runAsNonRoot: true
      fsGroup: 1001
      ## @extra webModeler.webapp.podSecurityContext.seccompProfile
      seccompProfile:
        ## @param webModeler.webapp.podSecurityContext.seccompProfile.type
        type: RuntimeDefault
    ## @extra webModeler.webapp.containerSecurityContext can be used to define the security options the webapp container should be run with
    ## @param webModeler.webapp.containerSecurityContext.privileged
    ## @param webModeler.webapp.containerSecurityContext.readOnlyRootFilesystem
    ## @param webModeler.webapp.containerSecurityContext.allowPrivilegeEscalation
    ## @param webModeler.webapp.containerSecurityContext.runAsNonRoot
    ## @param webModeler.webapp.containerSecurityContext.runAsUser
    containerSecurityContext:
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      ## @extra webModeler.webapp.containerSecurityContext.seccompProfile
      seccompProfile:
        ## @param webModeler.webapp.containerSecurityContext.seccompProfile.type
        type: RuntimeDefault

    ## @extra webModeler.webapp.startupProbe configuration of the webapp startup probe
    startupProbe:
      ## @param webModeler.webapp.startupProbe.enabled if true, the startup probe will be enabled for the webapp container
      enabled: false
      ## @param webModeler.webapp.startupProbe.scheme defines the startup probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.webapp.startupProbe.probePath defines the HTTP endpoint used for the startup probe
      probePath: /health/liveness
      ## @param webModeler.webapp.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 15
      ## @param webModeler.webapp.startupProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.webapp.startupProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.webapp.startupProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.webapp.startupProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.webapp.readinessProbe configuration of the webapp readiness probe
    readinessProbe:
      ## @param webModeler.webapp.readinessProbe.enabled if true, the readiness probe will be enabled for the webapp container
      enabled: true
      ## @param webModeler.webapp.readinessProbe.scheme defines the startup probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.webapp.readinessProbe.probePath defines the HTTP endpoint used for the readiness probe
      probePath: /health/readiness
      ## @param webModeler.webapp.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 15
      ## @param webModeler.webapp.readinessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.webapp.readinessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.webapp.readinessProbe.failureThreshold defines when the probe is considered failed so the Pod will be marked unready
      failureThreshold: 5
      ## @param webModeler.webapp.readinessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.webapp.livenessProbe configuration of the webapp liveness probe
    livenessProbe:
      ## @param webModeler.webapp.livenessProbe.enabled if true, the liveness probe will be enabled for the webapp container
      enabled: false
      ## @param webModeler.webapp.livenessProbe.scheme defines the startup probe schema used on calling the probePath
      scheme: HTTP
      ## @param webModeler.webapp.livenessProbe.probePath defines the HTTP endpoint used for the liveness probe
      probePath: /health/liveness
      ## @param webModeler.webapp.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 15
      ## @param webModeler.webapp.livenessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.webapp.livenessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.webapp.livenessProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.webapp.livenessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## Metrics configuration
    metrics:
      ## @param webModeler.webapp.metrics.prometheus Prometheus metrics endpoint
      prometheus: /metrics

    ## @param webModeler.webapp.nodeSelector can be used to select the nodes the webapp pods should run on
    nodeSelector: {}
    ## @param webModeler.webapp.tolerations can be used to define pod tolerations, see https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
    tolerations: []
    ## @param webModeler.webapp.affinity can be used to define pod affinity or anti-affinity, see https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
    affinity: {}

    ## @extra webModeler.webapp.resources configuration of resource requests and limits for the container, see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
    ## @param webModeler.webapp.resources.requests.cpu
    ## @param webModeler.webapp.resources.requests.memory
    ## @param webModeler.webapp.resources.limits.cpu
    ## @param webModeler.webapp.resources.limits.memory
    resources:
      requests:
        cpu: 400m
        memory: 256Mi
      limits:
        cpu: 800m
        memory: 512Mi

    ## @extra webModeler.webapp.service configuration of the WebModeler webapp service
    service:
      ## @param webModeler.webapp.service.annotations can be used to define annotations which will be applied to the service
      annotations: {}
      ## @param webModeler.webapp.service.type defines the type of the service, see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
      type: ClusterIP
      ## @param webModeler.webapp.service.port defines the port of the service
      port: 80
      ## @param webModeler.webapp.service.managementPort defines the management port of the service
      managementPort: 8071

    ## @param webModeler.webapp.configuration if specified, contents will be used as the application.yaml
    configuration: ""
    ## @param webModeler.webapp.extraConfiguration if specified, contents will be used for any extra configuration files such as log4j2.xml
    extraConfiguration: {}
    ## @param webModeler.webapp.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
    dnsPolicy: ""
    ## @param webModeler.webapp.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
    dnsConfig: {}

  # WebModeler.
  #    # ###### #####   ####   ####   ####  #    # ###### #####  ####
  #    # #      #    # #      #    # #    # #   #  #        #   #
  #    # #####  #####   ####  #    # #      ####   #####    #    ####
  # ## # #      #    #      # #    # #      #  #   #        #        #
  ##  ## #      #    # #    # #    # #    # #   #  #        #   #    #
  #    # ###### #####   ####   ####   ####  #    # ######   #    ####
  ## @section WebModeler - WebSockets Parameters
  ## @extra webModeler.websockets configuration of the WebModeler websockets component
  websockets:
    ## @extra webModeler.websockets.image configuration of the websockets Docker image
    image:
      ## @param webModeler.websockets.image.repository defines which image repository to use for the websockets Docker image
      repository: camunda/web-modeler-websockets

    ## @param webModeler.websockets.sidecars can be used to attach extra containers to the modeler websockets deployment
    sidecars: []
    ## @param webModeler.websockets.initContainers can be used to set up extra init containers for the application Pod
    initContainers: []

    ## @param webModeler.websockets.publicHost can be used to define the host on which the WebSockets server can be reached from the WebModeler client in the browser.
    # The default value assumes that a port-forwarding to the websockets service has been created.
    # Note: The host will only be used if the Ingress resource for WebModeler is disabled.
    publicHost: localhost
    ## @param webModeler.websockets.publicPort can be used to define the port number on which the WebSockets server can be reached from the WebModeler client in the browser.
    # The default value assumes that a port-forwarding to the websockets service on port 8085 has been created.
    # Note: The port will only be used if the Ingress resource for WebModeler is disabled.
    publicPort: 8085

    ## @param webModeler.websockets.podAnnotations can be used to define extra websockets pod annotations
    podAnnotations: {}
    ## @param webModeler.websockets.podLabels can be used to define extra websockets pod labels
    podLabels: {}

    ## @param webModeler.websockets.env can be used to set extra environment variables in each websockets container
    env: []
    ## @param webModeler.websockets.envFrom list of environment variables to import from configMapRef and secretRef
    envFrom: []
    ## @param webModeler.websockets.command can be used to override the default command provided by the container image, see https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
    command: []
    ## @param webModeler.websockets.extraVolumes can be used to define extra volumes for the websockets pod; useful for logging to a file
    extraVolumes: []
    ## @param webModeler.websockets.extraVolumeMounts can be used to mount extra volumes for the websockets pod; useful for logging to a file
    extraVolumeMounts: []

    ## @extra webModeler.websockets.podSecurityContext can be used to define the security options the websockets pod should be run with
    ## @param webModeler.websockets.podSecurityContext.runAsNonRoot
    ## @param webModeler.websockets.podSecurityContext.fsGroup
    podSecurityContext:
      runAsNonRoot: true
      fsGroup: 1001
      ## @extra webModeler.websockets.podSecurityContext.seccompProfile
      seccompProfile:
        ## @param webModeler.websockets.podSecurityContext.seccompProfile.type
        type: RuntimeDefault
    ## @extra webModeler.websockets.containerSecurityContext can be used to define the security options the websockets container should be run with
    ## @param webModeler.websockets.containerSecurityContext.privileged
    ## @param webModeler.websockets.containerSecurityContext.readOnlyRootFilesystem
    ## @param webModeler.websockets.containerSecurityContext.allowPrivilegeEscalation
    ## @param webModeler.websockets.containerSecurityContext.runAsNonRoot
    ## @param webModeler.websockets.containerSecurityContext.runAsUser
    containerSecurityContext:
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      ## @extra webModeler.websockets.containerSecurityContext.seccompProfile
      seccompProfile:
        ## @param webModeler.websockets.containerSecurityContext.seccompProfile.type
        type: RuntimeDefault

    ## @extra webModeler.websockets.startupProbe configuration of the websockets startup probe
    startupProbe:
      ## @param webModeler.websockets.startupProbe.enabled if true, the startup probe will be enabled for the websockets container
      enabled: false
      ## @param webModeler.websockets.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 10
      ## @param webModeler.websockets.startupProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.websockets.startupProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.websockets.startupProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.websockets.startupProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.websockets.readinessProbe configuration of the websockets readiness probe
    readinessProbe:
      ## @param webModeler.websockets.readinessProbe.enabled if true, the readiness probe will be enabled for the websockets container
      enabled: true
      ## @param webModeler.websockets.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 10
      ## @param webModeler.websockets.readinessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.websockets.readinessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.websockets.readinessProbe.failureThreshold defines when the probe is considered failed so the Pod will be marked unready
      failureThreshold: 5
      ## @param webModeler.websockets.readinessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @extra webModeler.websockets.livenessProbe configuration of the websockets liveness probe
    livenessProbe:
      ## @param webModeler.websockets.livenessProbe.enabled if true, the liveness probe will be enabled for the websockets container
      enabled: false
      ## @param webModeler.websockets.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated
      initialDelaySeconds: 10
      ## @param webModeler.websockets.livenessProbe.periodSeconds defines how often the probe is executed
      periodSeconds: 30
      ## @param webModeler.websockets.livenessProbe.successThreshold defines how often the probe needs to succeed to be considered successful after having failed
      successThreshold: 1
      ## @param webModeler.websockets.livenessProbe.failureThreshold defines when the probe is considered failed so the container will be restarted
      failureThreshold: 5
      ## @param webModeler.websockets.livenessProbe.timeoutSeconds defines the number of seconds after which the probe times out
      timeoutSeconds: 1

    ## @param webModeler.websockets.nodeSelector can be used to select the nodes the websockets pods should run on
    nodeSelector: {}
    ## @param webModeler.websockets.tolerations can be used to define pod tolerations, see https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
    tolerations: []
    ## @param webModeler.websockets.affinity can be used to define pod affinity or anti-affinity, see https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
    affinity: {}

    ## @extra webModeler.websockets.resources configuration of resource requests and limits for the container, see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
    ## @param webModeler.websockets.resources.requests.cpu
    ## @param webModeler.websockets.resources.requests.memory
    ## @param webModeler.websockets.resources.limits.cpu
    ## @param webModeler.websockets.resources.limits.memory
    resources:
      requests:
        cpu: 100m
        memory: 64Mi
      limits:
        cpu: 200m
        memory: 128Mi

    ## @extra webModeler.websockets.service configuration of the WebModeler websockets service
    service:
      ## @param webModeler.websockets.service.annotations can be used to define annotations which will be applied to the service
      annotations: {}
      ## @param webModeler.websockets.service.type defines the type of the service, see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
      type: ClusterIP
      ## @param webModeler.websockets.service.port defines the port of the service
      port: 80
    ## @param webModeler.websockets.configuration if specified, contents will be used as the application.yaml
    configuration: ""
    ## @param webModeler.websockets.extraConfiguration if specified, contents will be used for any extra configuration files such as log4j2.xml
    extraConfiguration: {}
    ## @param webModeler.websockets.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
    dnsPolicy: ""
    ## @param webModeler.websockets.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
    dnsConfig: {}

  ## @extra webModeler.serviceAccount configuration for the service account the WebModeler pods are assigned to
  serviceAccount:
    ## @param webModeler.serviceAccount.enabled if true, enables the WebModeler service account
    enabled: true
    ## @param webModeler.serviceAccount.name can be used to set the name of the WebModeler service account
    name: ""
    ## @param webModeler.serviceAccount.annotations can be used to set the annotations of the WebModeler service account
    annotations: {}
    ## @param webModeler.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: false

# WebModeler.
#####   ####   ####  #####  ####  #####  ######  ####   ####  #
#    # #    # #        #   #    # #    # #      #      #    # #
#    # #    #  ####    #   #      #    # #####   ####  #    # #
#####  #    #      #   #   #  ### #####  #           # #  # # #
#      #    # #    #   #   #    # #   #  #      #    # #   #  #
#       ####   ####    #    ####  #    # ######  ####   ### # ######
## @section WebModeler - PostgreSQL Parameters
## @extra postgresql configuration for the postgresql dependency chart used by WebModeler. See the chart documentation https://github.com/bitnami/charts/tree/master/bitnami/postgresql#parameters for more details.
webModelerPostgresql:
  ## @param webModelerPostgresql.enabled if true, a PostgreSQL database will be deployed as part of the Helm release by using the dependency chart
  # Note: If WebModeler is enabled, and WebModeler Postgresql is disabled, the external database configuration must be set under "webModeler.restapi.externalDatabase".
  enabled: false
  ## @extra postgresql.global.compatibility Compatibility adaptations for Kubernetes platforms
  global:
    ## Compatibility adaptations for Kubernetes platforms
    ##
    compatibility:
      ## Compatibility adaptations for Openshift
      ##
      openshift:
        ## @param webModelerPostgresql.global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: force (perform the adaptation always), disabled (do not perform adaptation)
        ##
        adaptSecurityContext: "{{ .Values.global.compatibility.openshift.adaptSecurityContext | default \"disabled\" }}"
  ## @param webModelerPostgresql.nameOverride defines the name of the Postgres resources (names will be prefixed with the release name), see https://github.com/bitnami/charts/tree/main/bitnami/postgresql#common-parameters
  # Note: Don't use the name "postgresql" which is already used for Keycloak's database.
  nameOverride: postgresql-web-modeler
  # https://hub.docker.com/r/bitnami/postgresql/tags
  ## @param webModelerPostgresql.image.repository PostgreSQL repo
  ## @param webModelerPostgresql.image.tag PostgreSQL image tag
  image:
    repository: bitnami/postgresql
    tag: 14.17.0-debian-12-r2
  ## @extra postgresql.auth configuration of the database authentication
  auth:
    ## @param webModelerPostgresql.auth.username defines the name of the database user to be created for WebModeler
    username: web-modeler
    ## @param webModelerPostgresql.auth.password can be used to provide the database user's password; a random password will be generated if left empty / ignored if `postgresql.auth.existingSecret` is set
    password: ""
    ## @param webModelerPostgresql.auth.database defines the name of the database to be created for WebModeler
    database: web-modeler
    ## @param webModelerPostgresql.auth.existingSecret can be used to provide the name of an existing secret resource containing the database password
    existingSecret: ""
    secretKeys:
      ## @param webModelerPostgresql.auth.secretKeys.adminPasswordKey defines the key within the existing secret object for PostgreSQL admin.
      adminPasswordKey: "postgres-password"
      ## @param webModelerPostgresql.auth.secretKeys.userPasswordKey defines the key within the existing secret object for PostgreSQL user.
      userPasswordKey: "password"

  ## @param webModelerPostgresql.primary.containerSecurityContext.enabled
  ## @param webModelerPostgresql.primary.containerSecurityContext.allowPrivilegeEscalation
  ## @param webModelerPostgresql.primary.containerSecurityContext.privileged
  ## @param webModelerPostgresql.primary.containerSecurityContext.readOnlyRootFilesystem
  ## @param webModelerPostgresql.primary.containerSecurityContext.runAsNonRoot
  ## @param webModelerPostgresql.primary.containerSecurityContext.runAsUser
  ## @param webModelerPostgresql.primary.containerSecurityContext.capabilities.drop
  ## @param webModelerPostgresql.primary.containerSecurityContext.seccompProfile.type
  primary:
    containerSecurityContext:
      enabled: true
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      capabilities:
        drop: ["ALL"]
      seccompProfile:
        type: RuntimeDefault
    ## @param webModelerPostgresql.primary.podSecurityContext.enabled
    ## @param webModelerPostgresql.primary.podSecurityContext.runAsNonRoot
    ## @param webModelerPostgresql.primary.podSecurityContext.fsGroup
    podSecurityContext:
      enabled: true
      runAsNonRoot: true
      fsGroup: 1001


#------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------------------------#
############################################################################################################################
 #######                                                                                  #####                              
 #     # #####   ####  #    # ######  ####  ##### #####    ##   ##### #  ####  #    #    #     # #####   ####  #    # #####  
 #     # #    # #    # #    # #      #        #   #    #  #  #    #   # #    # ##   #    #       #    # #    # #    # #    # 
 #     # #    # #      ###### #####   ####    #   #    # #    #   #   # #    # # #  #    #  #### #    # #    # #    # #    # 
 #     # #####  #      #    # #           #   #   #####  ######   #   # #    # #  # #    #     # #####  #    # #    # #####  
 #     # #   #  #    # #    # #      #    #   #   #   #  #    #   #   # #    # #   ##    #     # #   #  #    # #    # #      
 ####### #    #  ####  #    # ######  ####    #   #    # #    #   #   #  ####  #    #     #####  #    #  ####   ####  #      
############################################################################################################################
#------------------------------------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------------------------#


#####################################################################
 #####
#     #  ####  #    # #    # ######  ####  #####  ####  #####   ####
#       #    # ##   # ##   # #      #    #   #   #    # #    # #
#       #    # # #  # # #  # #####  #        #   #    # #    #  ####
#       #    # #  # # #  # # #      #        #   #    # #####       #
#     # #    # #   ## #   ## #      #    #   #   #    # #   #  #    #
 #####   ####  #    # #    # ######  ####    #    ####  #    #  ####
#####################################################################
## @section Connectors Parameters
## @extra connectors configuration for the Connectors.
connectors:
  ## @param connectors.enabled if true, the Connectors deployment and its related resources are deployed via a helm release
  enabled: true

  ## @extra connectors.inbound Switch for inbound mode (e.g., for webhook or polling)
  inbound:
    ## @param connectors.inbound.mode acceptable values: disabled, credentials, or oauth
    mode: oauth
    ## @extra connectors.inbound.auth configuration of the credentials authentication.
    auth:
      ## @param connectors.inbound.auth.existingSecret can be used to configure Secret name that contains password (if inbound mode is credentials)
      existingSecret: ""
      ## @param connectors.inbound.auth.existingSecretKey defines the key within the existing secret object.
      existingSecretKey: "connectors-secret"

  ## @extra connectors.image configuration to configure the Connectors image specifics
  # https://hub.docker.com/r/camunda/connectors-bundle/tags
  image:
    ## @param connectors.image.registry can be used to set container image registry.
    registry: ""
    ## @param connectors.image.repository defines which image repository to use
    repository: camunda/connectors-bundle
    ## @param connectors.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag: 8.8.0-alpha1
    ## @param connectors.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @param connectors.sidecars can be used to attach extra containers to the connectors deployment
  sidecars: []
  ## @param connectors.initContainers can be used to set up extra init containers for the application Pod
  initContainers: []

  ## @param connectors.replicas number of Connectors replicas
  replicas: 1

  # contextPath: "/connectors"
  ## @param connectors.contextPath can be used to make Connectors web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @param connectors.podAnnotations can be used to define extra Connectors pod annotations
  podAnnotations: {}
  ## @param connectors.podLabels can be used to define extra Connectors pod labels
  podLabels: {}

  ## @extra connectors.logging configuration for the Connectors logging. This template will be directly included in the connector configuration YAML file
  ## @param connectors.logging.level.io.camunda.connector
  logging:
    level:
      io.camunda.connector: ERROR

  ## @extra connectors.service configuration to configure the Connectors service.
  service:
    ## @param connectors.service.annotations can be used to define annotations, which will be applied to the Connectors service
    annotations: {}
    ## @param connectors.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param connectors.service.serverPort defines the port number where the Connector web application will be available
    serverPort: 8080
    ## @param connectors.service.serverName defines the port name where the Connector web application will be available
    serverName: http

  ## @extra connectors.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @param connectors.resources.requests.cpu
  ## @param connectors.resources.requests.memory
  ## @param connectors.resources.limits.cpu
  ## @param connectors.resources.limits.memory
  resources:
    requests:
      cpu: 1
      memory: 1Gi
    limits:
      cpu: 2
      memory: 2Gi

  ## @param connectors.env can be used to set extra environment variables in each Connector container
  env: []
  ## @param connectors.envFrom list of environment variables to import from configMapRef and secretRef
  envFrom: []
  ## @param connectors.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  ## @param connectors.extraVolumes can be used to define extra volumes for the Connectors pods, useful for TLS and self-signed certificates
  extraVolumes: []
  ## @param connectors.extraVolumeMounts can be used to mount extra volumes for the Connectors pods, useful for TLS and self-signed certificates
  extraVolumeMounts: []

  ## @extra connectors.startupProbe configuration
  startupProbe:
    ## @param connectors.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param connectors.startupProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param connectors.startupProbe.probePath defines the startup probe route used on the app
    probePath: /actuator/health/readiness
    ## @param connectors.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param connectors.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param connectors.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param connectors.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param connectors.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra connectors.readinessProbe configuration
  readinessProbe:
    # TODO: Enalbe the readiness again once the Zeebe client in Connectors is updated (it should be done before 8.8 release).
    ## @param connectors.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param connectors.readinessProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param connectors.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /actuator/health/readiness
    ## @param connectors.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
    ## @param connectors.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param connectors.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param connectors.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param connectors.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra connectors.livenessProbe configuration
  livenessProbe:
    ## @param connectors.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param connectors.livenessProbe.scheme defines the startup probe scheme used on calling the probePath
    scheme: HTTP
    ## @param connectors.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /actuator/health/liveness
    ## @param connectors.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    ## @param connectors.livenessProbe.initialDelaySeconds the probe is initiated.
    initialDelaySeconds: 30
    ## @param connectors.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param connectors.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param connectors.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param connectors.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## Metrics configuration
  metrics:
    ## @param connectors.metrics.prometheus Prometheus metrics endpoint
    prometheus: /actuator/prometheus

  ## @extra connectors.serviceAccount configuration for the service account where the Connectors pods are assigned to
  serviceAccount:
    ## @param connectors.serviceAccount.enabled if true, enables the Connectors service account
    enabled: true
    ## @param connectors.serviceAccount.name can be used to set the name of the Connectors service account
    name: ""
    ## @param connectors.serviceAccount.annotations can be used to set the annotations of the service account
    annotations: {}
    ## @param connectors.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: false

  ## @extra connectors.podSecurityContext defines the security options the Connectors pod should be run with
  podSecurityContext:
    ## @param connectors.podSecurityContext.runAsNonRoot run as non root
    runAsNonRoot: true
    ## @param connectors.podSecurityContext.fsGroup
    fsGroup: 1001
    ## @extra connectors.podSecurityContext.seccompProfile
    seccompProfile:
      ## @param connectors.podSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra connectors.containerSecurityContext defines the security options the Connectors container should be run with
  ## @param connectors.containerSecurityContext.privileged
  ## @param connectors.containerSecurityContext.readOnlyRootFilesystem
  ## @param connectors.containerSecurityContext.allowPrivilegeEscalation
  ## @param connectors.containerSecurityContext.runAsNonRoot
  ## @param connectors.containerSecurityContext.runAsUser
  containerSecurityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1001
    ## @extra connectors.containerSecurityContext.seccompProfile
    seccompProfile:
      ## @param connectors.containerSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @param connectors.nodeSelector can be used to define on which nodes the Connectors pods should run
  nodeSelector: {}
  ## @param connectors.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @param connectors.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}
  ## @param connectors.configuration if specified, contents will be used as the application.yaml
  configuration: ""
  ## @param connectors.extraConfiguration if specified, contents will be used for any extra configuration files such as the log4j2.xml
  extraConfiguration: {}
  ## @param connectors.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
  dnsPolicy: ""
  ## @param connectors.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  dnsConfig: {}

############################
 #####                       
#     #  ####  #####  ######
#       #    # #    # #     
#       #    # #    # ##### 
#       #    # #####  #     
#     # #    # #   #  #     
 #####   ####  #    # ######
############################

## @section Orchestration Core Parameters
## @extra core configuration for the Orchestration Core.
core:
  ## @param core.enabled if true, all related resources are deployed via the helm release
  enabled: true

  ## @param core.debug if true, extra info is printed.
  debug: false

  ## @extra core.image configuration to configure the image specifics
  image:
     ## @param core.image.registry can be used to set container image registry.
    registry: ""
     ## @param core.image.repository defines which image repository to use
    repository: camunda/camunda
     ## @param core.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag: 8.8.0-alpha1
     ## @param core.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @param core.sidecars can be used to attach extra containers to the deployment
  sidecars: []

  ## @param core.clusterSize defines the amount of brokers (=replicas), which are deployed via helm
  clusterSize: "3"
  ## @param core.partitionCount defines how many partitions are set up in the cluster
  partitionCount: "3"
  ## @param core.replicationFactor defines how each partition is replicated, the value defines the number of nodes
  replicationFactor: "3"
  ## @param core.env can be used to set extra environment variables in each broker container
  env: []
    # - name: LOGGING_LEVEL_IO_CAMUNDA
    #   value: DEBUG
    # - name: LOGGING_LEVEL_ORG_SPRINGFRAMEWORK
    #   value: TRACE
    # - name: LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_SECURITY
    #   value: TRACE
  ## @param core.envFrom list of environment variables to import from configMapRef and secretRef
  envFrom: []
  ## @extra core.configMap configuration which will be applied to the mounted config map.
  configMap:
     ## @param core.configMap.defaultMode can be used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. see https://github.com/kubernetes/api/blob/master/core/v1/types.go#L1615-L1623
    defaultMode: 0754
  ## @param core.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []

  ## @param core.logLevel defines the log level which is used
  logLevel: info
  ## @param core.log4j2 can be used to overwrite the log4j2 configuration
  log4j2: ''
  ## @param core.javaOpts can be used to set java options
  javaOpts: >-
    -XX:+HeapDumpOnOutOfMemoryError
    -XX:HeapDumpPath=/usr/local/camunda/data
    -XX:ErrorFile=/usr/local/camunda/data/zeebe_error%p.log
    -XX:+ExitOnOutOfMemoryError

  ## @extra core.service configuration for the broker service
  service:
    ## @param core.service.annotations can be used to define annotations, which will be applied to the service
    annotations: {}
    ## @param core.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param core.service.httpPort defines the port of the http endpoint, where for example metrics are provided
    httpPort: 8080
    ## @param core.service.httpName defines the name of the http endpoint, where for example metrics are provided
    httpName: "http"
    ## @param core.service.commandPort defines the port of the command api endpoint, where the broker commands are sent to
    commandPort: 26501
    ## @param core.service.commandName defines the name of the command api endpoint, where the broker commands are sent to
    commandName: "command"
    ## @param core.service.internalPort defines the port of the internal api endpoint, which is used for internal communication
    internalPort: 26502
    ## @param core.service.internalName defines the name of the internal api endpoint, which is used for internal communication
    internalName: "internal"
    ## @param core.service.extraPorts can be used to expose any other ports which are required. Can be useful for exporters
    extraPorts: []
      # - name: hazelcast
      #   protocol: TCP
      #   port: 5701
      #   targetPort: 5701
    ## @param core.service.grpcPort defines the port of the gateway gRPC endpoint, where client commands (grpc) are sent to
    grpcPort: 26500
    ## @param core.service.grpcName defines the name of the gateway gRPC endpoint, where client commands (grpc) are sent to
    grpcName: "gateway"
    ## @param core.service.managementPort
    managementPort: 9600
    ## @param core.service.managementName
    managementName: "server"

  ## @extra global.core.ServiceAccount configuration for the service account where the broker pods are assigned to
  serviceAccount:
    ## @param core.serviceAccount.enabled if true, enables the broker service account
    enabled: true
    ## @param core.serviceAccount.name can be used to set the name of the broker service account
    name: ""
    ## @param core.serviceAccount.annotations can be used to set the annotations of the broker service account
    annotations: {}
    ## @param core.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: false

  ingress:
    grpc:
      ## @param core.ingress.grpc.enabled if true, an ingress resource is deployed with the Zeebe gateway deployment. Only useful if an ingress controller is available, like nginx.
      enabled: false
      ## @param core.ingress.grpc.className defines the class or configuration of ingress which should be used by the controller
      className: nginx
      ## @param core.ingress.grpc.annotations [object] defines the ingress related annotations, consumed mostly by the ingress controller
      ## @skip core.ingress.grpc.annotations.ingress.kubernetes.io/rewrite-target
      ## @skip core.ingress.grpc.annotations.nginx.ingress.kubernetes.io/ssl-redirect
      ## @skip core.ingress.grpc.annotations.nginx.ingress.kubernetes.io/backend-protocol
      ## @skip core.ingress.grpc.annotations.nginx.ingress.kubernetes.io/proxy-buffer-size
      annotations:
        ingress.kubernetes.io/rewrite-target: '/'
        nginx.ingress.kubernetes.io/ssl-redirect: 'false'
        nginx.ingress.kubernetes.io/backend-protocol: 'GRPC'
        nginx.ingress.kubernetes.io/proxy-buffer-size: '128k'
      ## @param core.ingress.grpc.path defines the path which is associated with the Zeebe gateway's gRPC service and port https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
      path: /
      ## @param core.ingress.grpc.pathType can be used to define the Ingress path type. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types
      pathType: Prefix
      ## @param core.ingress.grpc.host can be used to define the host of the ingress rule. https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
      # If not specified the rules applies to all inbound gRPC traffic, if specified the rule applies to that host.
      host: ""
      ## @extra core.ingress.grpc.tls configuration for tls on the ingress resource https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
      tls:
        ## @param core.ingress.grpc.tls.enabled if true, then tls is configured on the ingress resource. If enabled the Ingress.host need to be defined.
        enabled: false
        ## @param core.ingress.grpc.tls.secretName defines the secret name which contains the TLS private key and certificate
        secretName: camunda-platform-core-grpc

  # contextPath: "/core"
  ## @param core.contextPath can be used to make Core web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @param core.cpuThreadCount defines how many threads can be used for the processing on each broker pod
  cpuThreadCount: "3"
  ## @param core.ioThreadCount defines how many threads can be used for the exporting on each broker pod
  ioThreadCount: "3"
  ## @extra core.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @extra core.resources.requests
  ## @param core.resources.requests.cpu
  ## @param core.resources.requests.memory
  ## @param core.resources.limits.cpu
  ## @param core.resources.limits.memory
  resources:
    requests:
      cpu: 1000m
      memory: 1500Mi
    limits:
      cpu: 2000m
      memory: 3000Mi

  ## @param core.persistenceType defines the type of persistence which is used by core. Possible values are: disk, local and memory.
  #   disk  - means a persistence volume claim is configured and used
  #   local - means the data is stored into the container, no volumeMount nor volume nor claim is configured
  #   memory   - means it uses a tmpfs for the data persistence, be aware that this takes the limits into account
  persistenceType: disk
  ## @param core.pvcSize defines the persistent volume claim size, which is used by each broker pod https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims
  pvcSize: "32Gi"
  ## @param core.pvcAccessModes can be used to configure the persistent volume claim access mode https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes
  pvcAccessModes: ["ReadWriteOnce"]
  ## @param core.pvcStorageClassName can be used to set the storage class name which should be used by the persistent volume claim.
  # It is recommended to use a storage class, which is backed with a SSD. Set to "-" to disable use of default storage class.
  pvcStorageClassName: ''
  ## @param core.pvcAnnotations can be used to specify custom annotations for persistent volume claims, enhancing storage configuration flexibility.
  pvcAnnotations: {}
  ## @param core.pvcSelector can be used to specify a label selector for persistent volume claims for further filtering of the set of persistent volumes to select.
  # https://kubernetes.io/docs/concepts/storage/persistent-volumes/#selector
  pvcSelector: {}
  ## @param core.extraVolumes can be used to define extra volumes for the broker pods, useful for additional exporters
  extraVolumes: []
  ## @param core.extraVolumeMounts can be used to mount extra volumes for the broker pods, useful for additional exporters
  extraVolumeMounts: []
  ## @param core.extraInitContainers (Deprecated - use `initContainers` instead) ExtraInitContainers can be used to set up extra init containers for the broker pods, useful for additional exporters
  extraInitContainers: []
  ## @param core.initContainers can be used to set up extra init containers for the application Pod
  initContainers: []

  ## @param core.podAnnotations can be used to define extra broker pod annotations
  podAnnotations: {}
  ## @param core.podLabels can be used to define extra broker pod labels
  podLabels: {}
  ## @extra core.podDisruptionBudget configuration to configure a pod disruption budget for the broker pods https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  podDisruptionBudget:
    ## @param core.podDisruptionBudget.enabled if true a pod disruption budget is defined for the brokers
    enabled: false
    ## @param core.podDisruptionBudget.minAvailable can be used to set how many pods should be available. Be aware that if minAvailable is set, maxUnavailable will not be set (they are mutually exclusive).
    minAvailable: 0
    ## @param core.podDisruptionBudget.maxUnavailable can be used to set how many pods should be at max. unavailable
    maxUnavailable: 1

  ## @extra core.podSecurityContext defines the security options the pod should be run with
  podSecurityContext:
    ## @param core.podSecurityContext.runAsNonRoot run as non root
    runAsNonRoot: true
    ## @param core.podSecurityContext.fsGroup
    fsGroup: 1001
    ## @extra core.podSecurityContext.seccompProfile
    seccompProfile:
      ## @param core.podSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra core.containerSecurityContext defines the security options the container should be run with
  containerSecurityContext:
    ## @param core.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param core.containerSecurityContext.privileged
    privileged: false
    ## @param core.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param core.containerSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param core.containerSecurityContext.runAsUser
    runAsUser: 1001
    ## @extra core.containerSecurityContext.seccompProfile
    seccompProfile:
    ## @param core.containerSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra core.startupProbe configuration
  startupProbe:
    ## @param core.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param core.startupProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param core.startupProbe.probePath defines the startup probe route used on the app
    probePath: /actuator/health/startup
    ## @param core.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before the probe is initiated.
    initialDelaySeconds: 30
    ## @param core.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param core.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param core.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param core.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra core.readinessProbe configuration
  readinessProbe:
    ## @param core.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param core.readinessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param core.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /actuator/health/readiness
    ## @param core.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param core.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param core.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param core.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param core.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra core.livenessProbe configuration
  livenessProbe:
    ## @param core.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param core.livenessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param core.livenessProbe.probePath defines the liveness probe route used on the app. The path is intended to be the same as the readinessProbe. Refer to this issue for more details: https://github.com/camunda/camunda-platform-helm/issues/1849
    probePath: /actuator/health/readiness
    ## @param core.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param core.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param core.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param core.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param core.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## Metrics configuration
  metrics:
    ## @param core.metrics.prometheus Prometheus metrics endpoint
    prometheus: /actuator/prometheus

  ## @param core.nodeSelector can be used to define on which nodes the broker pods should run
  nodeSelector: {}
  ## @param core.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @extra global.core.Affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  # The default defined PodAntiAffinity allows constraining on which nodes the pods are scheduled on https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  # It uses a hard requirement for scheduling and works based on the pod labels
  ## @skip core.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].labelSelector.matchExpressions[0].key
  ## @skip core.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].labelSelector.matchExpressions[0].operator
  ## @skip core.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].labelSelector.matchExpressions[0].values
  ## @skip core.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution[0].topologyKey
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
              - key: "app.kubernetes.io/component"
                operator: In
                values:
                  - core
          topologyKey: "kubernetes.io/hostname"

  ## @param core.priorityClassName can be used to define the broker pods priority https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass
  priorityClassName: ""

  index:
    ## @param core.index.prefix if specified, defines web apps index prefix in Elasticsearch/OpenSearch. Note, for Zeebe index prefix, use "global.elasticsearch.prefix".
    prefix: ""

  archiver:
    ## @param core.archiver.enabled if false, there is no archiver which will continually create historical indices.
    enabled: true
    ## @param core.archiver.elsRolloverDateFormat defines the date format of historical indices in a Java DateTimeFormatter compliant syntax.
    elsRolloverDateFormat: date
    ## @param core.archiver.rolloverInterval defines the time range of the historical indices to be created.
    rolloverInterval: 1d
    ## @param core.archiver.rolloverBatchSize defines the maximum number of process instances per batch during archiving.
    rolloverBatchSize: 100
    ## @param core.archiver.waitPeriodBeforeArchiving defines the grace period for processes to be excluded from archiving for a value of 1h, any processes completed in
    ## the last hour will not be collected into historical indices.
    waitPeriodBeforeArchiving: 1h
    ## @param core.archiver.delayBetweenRuns the millisecond interval between archiver runs
    delayBetweenRuns: 2000
    ## @param core.archiver.maxDelayBetweenRuns the maximum millisecond interval between archiver runs due to failure backoffs
    maxDelayBetweenRuns: 60000
    retention:
      ## @param core.archiver.retention.enabled if true, the ILM Policy is created and applied to the index templates.
      enabled: false
      ## @param core.archiver.retention.minimumAge defines how old the data must be, before the data is deleted as a duration.
      minimumAge: 30d
      ## @param core.archiver.retention.policyName defines the name of the created and applied ILM policy.
      policyName: core-record-retention-policy

  ## @param core.configuration if specified, contents will be used as the application.yaml
  configuration: ""
  ## @param core.extraConfiguration if specified, contents will be used for any extra configuration files such as log4j2.xml
  extraConfiguration: {}
  ## @param core.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
  dnsPolicy: ""
  ## @param core.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  dnsConfig: {}

#############################################
 #####
#     # #####  ##### # #    # # ###### ######
#     # #    #   #   # ##  ## #     #  #
#     # #    #   #   # # ## # #    #   #####
#     # #####    #   # #    # #   #    #
#     # #        #   # #    # #  #     #
 #####  #        #   # #    # # ###### ######
#############################################
## @section Optimize Parameters
# Optimize configuration for the Optimize sub chart.
optimize:
  ## @param optimize.enabled if true, the Optimize deployment and its related resources are deployed via a helm release
  enabled: true

  ## @extra optimize.image configuration to configure the Optimize image specifics
  # https://hub.docker.com/r/camunda/optimize/tags
  image:
    ## @param optimize.image.registry can be used to set container image registry
    registry: ""
    ## @param optimize.image.repository defines which image repository to use
    repository: camunda/optimize
    ## @param optimize.image.tag can be set to overwrite the global tag, which should be used in that chart
    tag: 8.8.0-alpha1
    ## @param optimize.image.pullSecrets can be used to configure image pull secrets https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    pullSecrets: []

  ## @extra optimize.migration configuration for Optimize migration
  migration:
    ## @param optimize.migration.enabled if true, run Optimize migration script as an init container
    enabled: true
    ## @param optimize.migration.env can be used to set environment variables for Optimize migration init container
    env: []

    ## @extra optimize.migration.resources configuration to set request and limit configuration for the migration container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
    ## @param optimize.migration.resources.requests.cpu
    ## @param optimize.migration.resources.requests.memory
    ## @param optimize.migration.resources.limits.cpu
    ## @param optimize.migration.resources.limits.memory
    resources:
      requests:
        cpu: 600m
        memory: 1Gi
      limits:
        cpu: 2000m
        memory: 2Gi

  ## @param optimize.sidecars can be used to attach extra containers to the optimize deployment
  sidecars: []

  # contextPath: "/optimize"
  ## @param optimize.contextPath can be used to make Optimize web application works on a custom sub-path. This is mainly used to run Camunda web applications under a single domain.
  contextPath: ""

  ## @extra optimize.configMap configuration which will be applied to the mounted config map.
  configMap:
    ## @param optimize.configMap.defaultMode can be used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    # See https://github.com/kubernetes/api/blob/master/core/v1/types.go#L1615-L1623
    defaultMode: 0754

  ## @param optimize.podAnnotations can be used to define extra Optimize pod annotations
  podAnnotations: {}
  ## @param optimize.podLabels can be used to define extra Optimize pod labels
  podLabels: {}

  ## @param optimize.logLevel configuration for the optimize runtime environment. https://docs.camunda.io/optimize/next/self-managed/optimize-deployment/configuration/logging/
  logLevel: info
  ## @param optimize.upgradeLogLevel sets the logging level for the Optimize update log. https://docs.camunda.io/optimize/next/self-managed/optimize-deployment/configuration/logging/
  upgradeLogLevel: info
  ## @param optimize.esLogLevel sets the logging level for Elasticsearch. https://docs.camunda.io/optimize/next/self-managed/optimize-deployment/configuration/logging/
  esLogLevel: warn

  ## @param optimize.partitionCount defines how many Zeebe partitions are set up in the cluster and which should be imported by Optimize
  partitionCount: "3"
  ## @param optimize.env can be used to set extra environment variables in each Optimize container
  env: []
  ## @param optimize.envFrom list of environment variables to import from configMapRef and secretRef
  envFrom: []
  ## @param optimize.command can be used to override the default command provided by the container image. See https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  command: []
  ## @param optimize.extraVolumes can be used to define extra volumes for the Optimize pods, useful for tls and self-signed certificates
  extraVolumes: []
  ## @param optimize.extraVolumeMounts can be used to mount extra volumes for the Optimize pods, useful for tls and self-signed certificates
  extraVolumeMounts: []
  ## @param optimize.initContainers can be used to set up extra init containers for the application Pod
  initContainers: []
  ## @extra optimize.serviceAccount configuration for the service account where the Optimize pods are assigned to
  serviceAccount:
    ## @param optimize.serviceAccount.enabled if true, enables the Optimize service account
    enabled: true
    ## @param optimize.serviceAccount.name can be used to set the name of the Optimize service account
    name: ""
    ## @param optimize.serviceAccount.annotations can be used to set the annotations of the Optimize service account
    annotations: {}
    ## @param optimize.serviceAccount.automountServiceAccountToken can be used to control whether the service account token should be automatically mounted
    automountServiceAccountToken: false

  ## @extra optimize.service configuration to configure the Optimize service.
  service:
    ## @param optimize.service.annotations can be used to define annotations, which will be applied to the Optimize service
    annotations: {}
    ## @param optimize.service.type defines the type of the service https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    ## @param optimize.service.port defines the port of the service, where the Optimize web application will be available
    port: 80
    ## @param optimize.service.managementPort defines the port where actuator will be available. Also required to reach backup API
    managementPort: 8092

  ## @extra optimize.podSecurityContext defines the security options the Optimize pod should be run with
  podSecurityContext:
    ## @param optimize.podSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param optimize.podSecurityContext.fsGroup
    fsGroup: 1001
    ## @extra optimize.podSecurityContext.seccompProfile
    seccompProfile:
      ## @param optimize.podSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra optimize.containerSecurityContext defines the security options the Optimize container should be run with
  containerSecurityContext:
    ## @param optimize.containerSecurityContext.allowPrivilegeEscalation
    allowPrivilegeEscalation: false
    ## @param optimize.containerSecurityContext.privileged
    privileged: false
    ## @param optimize.containerSecurityContext.readOnlyRootFilesystem
    readOnlyRootFilesystem: true
    ## @param optimize.containerSecurityContext.runAsNonRoot
    runAsNonRoot: true
    ## @param optimize.containerSecurityContext.runAsUser
    runAsUser: 1001
    ## @extra optimize.containerSecurityContext.seccompProfile
    seccompProfile:
      ## @param optimize.containerSecurityContext.seccompProfile.type
      type: RuntimeDefault

  ## @extra optimize.startupProbe configuration
  startupProbe:
    ## @param optimize.startupProbe.enabled if true, the startup probe is enabled in app container
    enabled: false
    ## @param optimize.startupProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param optimize.startupProbe.probePath defines the startup probe route used on the app
    probePath: /api/readyz
    ## @param optimize.startupProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param optimize.startupProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param optimize.startupProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param optimize.startupProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param optimize.startupProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra optimize.readinessProbe configuration
  readinessProbe:
    ## @param optimize.readinessProbe.enabled if true, the readiness probe is enabled in app container
    enabled: true
    ## @param optimize.readinessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param optimize.readinessProbe.probePath defines the readiness probe route used on the app
    probePath: /api/readyz
    ## @param optimize.readinessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param optimize.readinessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param optimize.readinessProbe.successThreshold defines how often it needs to be true to be marked as ready, after failure
    successThreshold: 1
    ## @param optimize.readinessProbe.failureThreshold defines when the probe is considered as failed so the Pod will be marked Unready
    failureThreshold: 5
    ## @param optimize.readinessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## @extra optimize.livenessProbe configuration
  livenessProbe:
    ## @param optimize.livenessProbe.enabled if true, the liveness probe is enabled in app container
    enabled: false
    ## @param optimize.livenessProbe.scheme defines the startup probe schema used on calling the probePath
    scheme: HTTP
    ## @param optimize.livenessProbe.probePath defines the liveness probe route used on the app
    probePath: /api/readyz
    ## @param optimize.livenessProbe.initialDelaySeconds defines the number of seconds after the container has started before
    # the probe is initiated.
    initialDelaySeconds: 30
    ## @param optimize.livenessProbe.periodSeconds defines how often the probe is executed
    periodSeconds: 30
    ## @param optimize.livenessProbe.successThreshold defines how often it needs to be true to be considered successful after having failed
    successThreshold: 1
    ## @param optimize.livenessProbe.failureThreshold defines when the probe is considered as failed so the container will be restarted
    failureThreshold: 5
    ## @param optimize.livenessProbe.timeoutSeconds defines the seconds after the probe times out
    timeoutSeconds: 1

  ## Metrics configuration
  metrics:
    ## @param optimize.metrics.prometheus Prometheus metrics endpoint
    prometheus: /actuator/prometheus

  ## @param optimize.nodeSelector can be used to define on which nodes the Optimize pods should run
  nodeSelector: {}
  ## @param optimize.tolerations can be used to define pod toleration's https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  ## @param optimize.affinity can be used to define pod affinity or anti-affinity https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}

  ## @extra optimize.resources configuration to set request and limit configuration for the container https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits
  ## @param optimize.resources.requests.cpu
  ## @param optimize.resources.requests.memory
  ## @param optimize.resources.limits.cpu
  ## @param optimize.resources.limits.memory
  resources:
    requests:
      cpu: 600m
      memory: 1Gi
    limits:
      cpu: 2000m
      memory: 2Gi

  ## @param optimize.configuration if specified, contents will be used as the environment-config.yaml
  configuration: ""
  ## @param optimize.extraConfiguration if specified, contents will be used for any extra configuration files such as environment-logback.xml
  extraConfiguration: {}
  ## @param optimize.dnsPolicy https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
  dnsPolicy: ""
  ## @param optimize.dnsConfig https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config
  dnsConfig: {}

#####################################################################################
#######
#       #        ##    ####  ##### #  ####   ####  ######   ##   #####   ####  #    #
#       #       #  #  #        #   # #    # #      #       #  #  #    # #    # #    #
#####   #      #    #  ####    #   # #       ####  #####  #    # #    # #      ######
#       #      ######      #   #   # #           # #      ###### #####  #      #    #
#       #      #    # #    #   #   # #    # #    # #      #    # #   #  #    # #    #
####### ###### #    #  ####    #   #  ####   ####  ###### #    # #    #  ####  #    #
#####################################################################################

## @section Elasticsearch Parameters

## @extra elasticsearch
elasticsearch:
  ## @param elasticsearch.enabled
  enabled: true
  ## @extra elasticsearch.global.compatibility Compatibility adaptations for Kubernetes platforms
  global:
    ## Compatibility adaptations for Kubernetes platforms
    ##
    compatibility:
      ## Compatibility adaptations for Openshift
      ##
      openshift:
        ## @param elasticsearch.global.compatibility.openshift.adaptSecurityContext Adapt the securityContext sections of the deployment to make them compatible with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and let the platform use their allowed default IDs. Possible values: force (perform the adaptation always), disabled (do not perform adaptation)
        ##
        adaptSecurityContext: "{{ .Values.global.compatibility.openshift.adaptSecurityContext | default \"disabled\" }}"
  # https://hub.docker.com/r/bitnami/elasticsearch/tags
  image:
    ## @param elasticsearch.image.repository
    repository: bitnami/elasticsearch
    ## @param elasticsearch.image.tag
    tag: 8.17.2
  master:
    ## @param elasticsearch.master.replicaCount defines number of master-elegible replicas to deploy
    replicaCount: 3
    ## @param elasticsearch.master.podAntiAffinityPreset defines Pod anti-affinity preset. Ignored if master.affinity is set
    podAntiAffinityPreset: hard
    containerSecurityContext:
    ## @param elasticsearch.master.containerSecurityContext.readOnlyRootFilesystem
      readOnlyRootFilesystem: true
    ## @param elasticsearch.master.masterOnly
    masterOnly: false
    ## @param elasticsearch.master.heapSize
    heapSize: 1024m
    persistence:
      ## @param elasticsearch.master.persistence.size
      size: 64Gi
    resources:
      requests:
        ## @param elasticsearch.master.resources.requests.cpu cpu request
        cpu: 1
        ## @param elasticsearch.master.resources.requests.memory request
        memory: 2Gi
      limits:
        ## @param elasticsearch.master.resources.limits.cpu cpu limit
        cpu: 2
        ## @param elasticsearch.master.resources.limits.memory memory limit
        memory: 2Gi
    extraEnvVars:
    ## @param elasticsearch.master.extraEnvVars[0].name env
    - name: ELASTICSEARCH_ENABLE_REST_TLS
    ## @param elasticsearch.master.extraEnvVars[0].value env value
      value: "false"
  sysctlImage:
  ## @param elasticsearch.sysctlImage.enabled
    enabled: true
  data:
    ## @param elasticsearch.data.replicaCount
    replicaCount: 0
  coordinating:
    ## @param elasticsearch.coordinating.replicaCount
    replicaCount: 0
  ingest:
    ## @param elasticsearch.ingest.enabled
    enabled: false

#####################################################################
######
#     # #####   ####  #    # ###### ##### #    # ###### #    #  ####
#     # #    # #    # ##  ## #        #   #    # #      #    # #
######  #    # #    # # ## # #####    #   ###### #####  #    #  ####
#       #####  #    # #    # #        #   #    # #      #    #      #
#       #   #  #    # #    # #        #   #    # #      #    # #    #
#       #    #  ####  #    # ######   #   #    # ######  ####   ####
#####################################################################

## @section Prometheus Parameters

## @extra PrometheusServiceMonitor configuration to configure a prometheus service monitor
prometheusServiceMonitor:
  ## @param prometheusServiceMonitor.enabled if true then a service monitor will be deployed, which allows an installed prometheus controller to scrape metrics from the deployed pods
  enabled: false
  ## @extra promotheuServiceMonitor.labels can be set to configure extra labels, which will be added to the servicemonitor and can be used on the prometheus controller for selecting the servicemonitors
  labels:
  ## @param prometheusServiceMonitor.labels.release
    release: metrics
  ## @param prometheusServiceMonitor.scrapeInterval can be set to configure the interval at which metrics should be scraped
  # Should be *less* than 60s if the provided grafana dashboard is used, which can be found here https://github.com/camunda/camunda/tree/main/monitor/grafana,
  # otherwise it isn't able to show any metrics which is aggregated over 1 min.
  scrapeInterval: 10s
